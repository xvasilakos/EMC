/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package sim.space.users;

import caching.MaxPop;
import caching.Utils;
import caching.base.AbstractCachingPolicy;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import sim.SimulationBaseRunner;
import sim.content.Chunk;
import sim.content.request.DocumentRequest;
import sim.space.cell.MacroCell;
import sim.space.cell.smallcell.SmallCell;

/**
 *
 * @author xvas
 */
public abstract class CachingUser extends User {

    private final Iterable<AbstractCachingPolicy> _cachingPolicies;
    private SmallCell _lastSCForCacheDecisions;
    private final Map<AbstractCachingPolicy, List<Chunk>> _mostRecentlyConsumedMC;
    private final Map<AbstractCachingPolicy, List<Chunk>> _mostRecentlyConsumedFromCacheHits;
    private final Map<AbstractCachingPolicy, List<Chunk>> _mostRecentlyConsumedBH;
    private final Map<AbstractCachingPolicy, List<Chunk>> _mostRecentlyCacheMissesPerPolicy;

    protected CachingUser(int id, SimulationBaseRunner<?> sim,
            Iterable<AbstractCachingPolicy> cachingPolicies) {

        super(id, sim);

        _lastSCForCacheDecisions = null;
        _cachingPolicies = cachingPolicies;

        _mostRecentlyConsumedMC = new HashMap<>();
        _mostRecentlyConsumedFromCacheHits = new HashMap<>();
        _mostRecentlyConsumedBH = new HashMap<>();
        _mostRecentlyCacheMissesPerPolicy = new HashMap<>();

        if (sim != null) {// dummy user
            for (AbstractCachingPolicy policy : sim.getCachingPolicies()) {
                _mostRecentlyConsumedMC.put(policy, new ArrayList<Chunk>());
                _mostRecentlyConsumedFromCacheHits.put(policy, new ArrayList<Chunk>());
                _mostRecentlyConsumedBH.put(policy, new ArrayList<Chunk>());
                _mostRecentlyCacheMissesPerPolicy.put(policy, new ArrayList<Chunk>());
            }
        }
    }

    protected CachingUser(int id, SimulationBaseRunner<?> sim, int connectedSinceSC, SmallCell connectionSC,
            MacroCell connectionMC,
            Iterable<AbstractCachingPolicy> cachingPolicies) {

        super(id, sim, connectedSinceSC, connectionSC, connectionMC);

        this._lastSCForCacheDecisions = null;
        _cachingPolicies = cachingPolicies;

        _mostRecentlyConsumedMC = new HashMap<>();
        _mostRecentlyConsumedFromCacheHits = new HashMap<>();
        _mostRecentlyConsumedBH = new HashMap<>();
        _mostRecentlyCacheMissesPerPolicy = new HashMap<>();

        if (sim != null) {// dummy user
            for (AbstractCachingPolicy policy : sim.getCachingPolicies()) {
                _mostRecentlyConsumedMC.put(policy, new ArrayList<Chunk>());
                _mostRecentlyConsumedFromCacheHits.put(policy, new ArrayList<Chunk>());
                _mostRecentlyConsumedBH.put(policy, new ArrayList<Chunk>());
                _mostRecentlyCacheMissesPerPolicy.put(policy, new ArrayList<Chunk>());
            }
        }
    }

    /**
     * @return the _lastSCForCacheDecisions
     */
    public SmallCell getLastSCForCacheDecisions() {
        return _lastSCForCacheDecisions;
    }

    /**
     * @param _lastSCForCacheDecisions the _lastSCForCacheDecisions to set
     */
    public void setLastSCForCacheDecisions(SmallCell _lastSCForCacheDecisions) {
        this._lastSCForCacheDecisions = _lastSCForCacheDecisions;
    }

    /**
     * @return the _cachingPolicies
     */
    public Iterable<AbstractCachingPolicy> getCachingPolicies() {
        return _cachingPolicies;
    }

    public final void cancelAndDeregisterPCOrders(SmallCell sc) {
        for (AbstractCachingPolicy policy : getSim().getCachingPolicies()) {
            if (policy instanceof MaxPop) {
                // cached object stay permanently in cache.
                continue;
            }
            Utils.cancelCachingOrders(
                    this,
                    policy,
                    sc
            );
            sc.getDmdPC(policy).deregisterUpdtInfoPC(this);
        }
    }

    @Override
    public void consumeData(int timeWindow) throws Throwable {
        // because one stationary emulates multiple stationary users with one request
        double slices
                = this instanceof StationaryUser ? 1
                        : getRequests().size();

        // equal (fair) slicing of rates to each request
        // caution, use double numbers to keep precision after divisions
        double mcRateSlice = Math.round((double) timeWindow * getSim().getRateMCWlessInBytes() / slices);
        double scRateSlice = Math.round((double) timeWindow * getSim().getRateSCWlessInBytes() / slices);
        double bhRateSlice = Math.round((double) timeWindow * getSim().getRateBHInBytes() / slices);
        bhRateSlice = Math.min(bhRateSlice, scRateSlice); // you download with minimum flow from the BH+SC network.

        // clear from previous move
        for (List<Chunk> recentChunks : _mostRecentlyConsumedMC.values()) {
            recentChunks.clear();
        }
        for (List<Chunk> recentChunks : _mostRecentlyConsumedFromCacheHits.values()) {
            recentChunks.clear();
        }
        for (List<Chunk> recentChunks : _mostRecentlyConsumedBH.values()) {
            recentChunks.clear();
        }
        for (List<Chunk> recentChunks : _mostRecentlyCacheMissesPerPolicy.values()) {
            recentChunks.clear();
        }

//xxx
//        String txt
//                = "\nConsumed for #reqs=" + reqs
//                + "\n\t mcRateSlice: " + mcRateSlice
//                + "\n\t scRateSlice: " + scRateSlice
//                + "\n\t bhRateSlice: " + bhRateSlice;
//        Utils.trackUser(false,
//                txt,
//                this, true);
        for (DocumentRequest nxtRequest : getRequests()) {
            nxtRequest.consumeChunks(mcRateSlice, _mostRecentlyConsumedMC,
                    scRateSlice, _mostRecentlyConsumedFromCacheHits,
                    bhRateSlice, _mostRecentlyConsumedBH,
                    _mostRecentlyCacheMissesPerPolicy
            );
        }

    }

    /**
     * @return the _mostRecentlyConsumedMC
     */
    public Map<AbstractCachingPolicy, List<Chunk>> getMostRecentlyConsumedMC() {
        return _mostRecentlyConsumedMC;
    }

    /**
     * @return the _mostRecentlyConsumedFromCacheHits
     */
    public Map<AbstractCachingPolicy, List<Chunk>> getMostRecentlyConsumedFromCacheHits() {
        return _mostRecentlyConsumedFromCacheHits;
    }

    /**
     * @return the _mostRecentlyConsumedBH
     */
    public Map<AbstractCachingPolicy, List<Chunk>> getMostRecentlyConsumedBH() {
        return _mostRecentlyConsumedBH;
    }

    /**
     * @return the _mostRecentlyCacheMissesPerPolicy
     */
    public Map<AbstractCachingPolicy, List<Chunk>> getMostRecentlyCacheMissesPerPolicy() {
        return _mostRecentlyCacheMissesPerPolicy;
    }

}
