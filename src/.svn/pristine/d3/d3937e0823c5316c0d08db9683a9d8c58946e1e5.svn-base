package app.arguments;

import app.properties.Preprocessor;
import exceptions.WrongOrImproperArgumentException;
import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.lang.reflect.Field;
import java.util.Properties;
import java.util.logging.Level;
import static logging.LoggersRegistry.CONSOLE_LOGGER;

/**
 *
 * @author Xenofon Vasilakos xvas@aueb.gr
 */
public class ArgumentsBean {
   public static ArgumentsBean NONE = new ArgumentsBean();

   public static class Defaults {

      private Defaults() {// do not instanciate
      }
      //<editor-fold defaultstate="collapsed" desc="load default values for arguments from properties file in classpath">
      private static final String ARGUMENTS__INI_CLASSPATH =
              "/" + ArgumentsBean.class.getPackage().toString().substring(8).trim().replace('.', '/')
              + "/default_arg_values.ini";

      private static Properties loadFromProperties() {
         Properties _LOADED_PROPS = new Properties();
         InputStream in = Preprocessor.class.getResourceAsStream(ARGUMENTS__INI_CLASSPATH);

         try {
            if (in == null) {
               throw new IOException("Resource loaded from " + ARGUMENTS__INI_CLASSPATH + " is null");
            }
            _LOADED_PROPS.load(in);
         } catch (IOException ioex) {
            String uponIOEX_msg = "Failed to load default properties file: " + ARGUMENTS__INI_CLASSPATH + "\n";
            CONSOLE_LOGGER.severe(uponIOEX_msg);
         }
         return _LOADED_PROPS;
      }
      //</editor-fold>
      private static final Properties PROPERTIES = loadFromProperties();
      public static final String SIMULATOR_PROPERTY__INI_CLASSPATH = "app/properties/default_property.values.ini";
      public static final int PARALLEL = Integer.parseInt(PROPERTIES.getProperty("parallel"));
   }

   public interface ArgFlag {
   }

   public enum Flag implements ArgFlag {

      DEFAULT("-default") {
         public boolean equals(Flag_shortcut _flag) {
            return  _flag.equals(Flag_shortcut.dash_d);
         }
      },
      /////////////////////
      VERBOSE("-verbose") {
         public boolean equals(Flag_shortcut _flag) {
            return  _flag.equals(Flag_shortcut.dash_v);
         }
      },
      /////////////////////
      PROPERTIES_PATH("-properties_path") {
         public boolean equals(Flag_shortcut _flag) {
            return  _flag.equals(Flag_shortcut.dash_pp);
         }
      },
      /////////////////////
      PARALLEL("-parallel") {
         public boolean equals(Flag_shortcut _flag) {
            return  _flag.equals(Flag_shortcut.dash_p);
         }
      };
      private final String flag;

      Flag(String _flag) {
         this.flag = _flag;
      }

      @Override
      public String toString() {
         return this.flag;
      }

      public boolean equals(String _flag) {
         return this.flag.equals(_flag);
      }

      public boolean equals(Flag _flag) {
         return this.flag.equals(_flag.flag);
      }
   }

   public enum Flag_shortcut implements ArgFlag {

      dash_d("-d") {
         public boolean equals(Flag _flag) {
            return this.toString().equals(Flag.DEFAULT.toString());
         }
      }, d("d"),
      /////////////////////
      dash_v("-v") {
         public boolean equals(Flag _flag) {
            return this.toString().equals(Flag.VERBOSE.toString());
         }
      }, v("v"),
      /////////////////////
      dash_pp("-pp") {
         public boolean equals(Flag _flag) {
            return this.toString().equals(Flag.PROPERTIES_PATH.toString());
         }
      }, pp("pp"),
      /////////////////////
      dash_p("-p") {
         public boolean equals(Flag _flag) {
            return this.toString().equals(Flag.PARALLEL.toString());
         }
      }, p("p");
      private final String flag;

      Flag_shortcut(String _flag) {
         this.flag = _flag;
      }

      @Override
      public String toString() {
         return this.flag;
      }

      public boolean equals(String _flag) {
         return this.flag.equals(_flag);
      }

      public boolean equals(Flag_shortcut _flag) {
         return this.flag.equals(_flag.flag);
      }
   }

   public enum MultiFlag implements ArgFlag {

      d("d"), v("v");
      private final String flag;

      MultiFlag(String _flag) {
         this.flag = _flag;
      }

      @Override
      public String toString() {
         return this.flag;
      }

      public boolean equals(String _flag) {
         return this.flag.equals(_flag);
      }

      public boolean equals(Flag _flag) {
         return _flag.equals(this);
      }

      public boolean equals(MultiFlag _flag) {
         return this.flag.equals(_flag.flag);
      }
   }
   private String propertiesPath;
   private int parallelSimsNum;

   private void defaults() {
      propertiesPath = Defaults.SIMULATOR_PROPERTY__INI_CLASSPATH;
      parallelSimsNum = Defaults.PARALLEL;
   }

   /**
    * uses default values.
    */
   public ArgumentsBean() {
      defaults();
   }
   
   private ArgumentsBean(String mokePath) {
      propertiesPath = mokePath;
      parallelSimsNum = -1;
   }

   public static ArgumentsBean load (String[] args) throws WrongOrImproperArgumentException {
      ArgumentsBean loaded = new ArgumentsBean(); // initially all defaults
      if (args.length == 0) {
         CONSOLE_LOGGER.log(Level.WARNING, "Using default arguments:\n{0}\n", loaded.toString());
         return loaded;
      }

      int i = 0, j;
      char flag;

      while (i < args.length && args[i].startsWith("-")) {
         String nxt_arg = args[i++];

         if (Flag.DEFAULT.equals(nxt_arg) || Flag_shortcut.dash_d.equals(nxt_arg)) {
            //<editor-fold defaultstate="collapsed" desc="default overides everything else">
            CONSOLE_LOGGER.log(Level.WARNING, "Default arguments mode. "
                  + "Other arguments passed (if any) overriden by default values.\n");
            
            return new ArgumentsBean();
            //</editor-fold>
         } else if (Flag.PROPERTIES_PATH.equals(nxt_arg) || Flag_shortcut.dash_pp.equals(nxt_arg)) {
            //<editor-fold defaultstate="collapsed" desc="handle properties input path">
            if (i < args.length) {
               loaded.propertiesPath = System.getProperty("user.home") 
                     + "/Dropbox/" + args[i++];//TODO call to system temporary solution during production only
            } else {
               String msg = "Argument \"" + nxt_arg + "\" requires a path to a file";
               throw new WrongOrImproperArgumentException(msg);
            }
            //</editor-fold>
         } else if (Flag.PARALLEL.equals(nxt_arg) || Flag_shortcut.dash_p.equals(nxt_arg)) {
            //<editor-fold defaultstate="collapsed" desc="handle properties input path">
            if (i < args.length) {
               loaded.parallelSimsNum = Integer.valueOf(args[i++]);
            } else {
               String msg = "Argument \"" + nxt_arg + "\" requires a path to a file";
               throw new WrongOrImproperArgumentException(msg);
            }
            //</editor-fold>
         } else {
            //<editor-fold defaultstate="collapsed" desc="Handle single letter options">
            for (j = 1;
                    j < nxt_arg.length();
                    j++) {// start from 1 to jump the "-"
               flag = nxt_arg.charAt(j);

               if (MultiFlag.d.equals(String.valueOf(flag))) {
                  CONSOLE_LOGGER.log(Level.FINE, "Default arguments mode on.. any other arguments will be ignored\n");
                  return new ArgumentsBean();
               } else if (MultiFlag.v.equals(String.valueOf(flag))) {
                  CONSOLE_LOGGER.setLevel(Level.ALL);
                  CONSOLE_LOGGER.setLevel(Level.ALL);
                  CONSOLE_LOGGER.log(Level.INFO, "verbose mode on\n");
               } else {
                  String msg = "Argument \"" + nxt_arg + "\":  illegal option or argument passed\n";
                  throw new WrongOrImproperArgumentException(msg);
               }
            }
            //</editor-fold>
         }
      }//while
      return loaded;
   }

   @Override
   public String toString() {
      StringBuilder _toString = new StringBuilder();
      String name = null;
      Object value = null;

      _toString.append("<");
      Field[] fields = getClass().getDeclaredFields();
      try {
         for (int index = 0; index < fields.length; index++) {
            fields[index].setAccessible(true);// print also static values
            name = fields[index].getName();
            value = fields[index].get(this);

            _toString.append('(').append(name).append(':').append(value).append(')');
            if (index < fields.length - 1) {
               _toString.append(';');
            }
         }
      } catch (IllegalArgumentException | IllegalAccessException ex) {
         // ignore.. :(
         value = "Cannot load value due to " + ex.getMessage();
         _toString.append('(').append(name).append(':').append(value).append(')');
      }
      _toString.append(">");
      return _toString.toString();
   }

   public String getPropertiesPath() {
      return this.propertiesPath;
   }
   public File getPropertiesParentDir() {
      return (new File(this.propertiesPath)).getParentFile();
   }
   public String getPropertiesParent() {
      return (new File(this.propertiesPath)).getParent();
   }

   public int getMaxConcurrentWorkers() {
      return this.parallelSimsNum;
   }
}
