package stats;

import app.properties.StatsProperty;
import exceptions.InconsistencyException;
import exceptions.InvalidOrUnsupportedException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.TreeSet;
import sim.ISimulationMember;
import sim.SimulationBase;
import sim.space.cell.CellRegistry;
import util.CommonFunctions;
import util.Couple;

/**
 * Instances of this class keep track of statistics over simTime.
 *
 * The values of each statistic recorded at a point of simulation simTime t are
 * kept in a instance of class StatsToValuesMapping, which in turn keeps the
 * multiple values mapped to the same statistics title. The StatsToValuesMapping
 * instance is mapped to the point of simTime t. Mapped
 * simTime-to-StatsToValuesMapping are kept in ascending order after simTime t.
 *
 * Note that there can be multiple values recorded in an StatsToValuesMapping
 * instance, which implies that many values for the same simTime t, that refer
 * to the same statistic, can be separately aggregated per within t.
 *
 * Last, this class offers the ability to aggregate all StatsToValuesMapping
 * separate aggregate values per statistic per simTime. This means that you can
 * compute the mean/stddev/variance/confidence interval values (through the
 * different times t recorded) of the different mean/stddev/variance/confidence
 * interval aggregates per each simTime t.
 *
 * @author xvas
 */
public class Statistics implements ISimulationMember {

    public static final int DEFAULT_ROUND_DECIMAL = 6;
    private final SortedMap<Integer, StatsToValuesMapping> _timeStatsRecorded;
    private final Set<String> _statisticsTitles;
    private final int _roundDecimal;

    private SimulationBase _simulation;
    private boolean _transientTitlesPrint;

    public Statistics(SimulationBase simulation) {
        _transientTitlesPrint = false;
        _statisticsTitles = new TreeSet<>();
        _timeStatsRecorded = new TreeMap();
        _roundDecimal = simulation.getScenario().intProperty(StatsProperty.STATS__ROUNDING_DECIMAL);
    }

    public Statistics(int roundDecimal) {
        _transientTitlesPrint = false;
        _statisticsTitles = new TreeSet<>();
        _timeStatsRecorded = new TreeMap();
        _roundDecimal = roundDecimal;
    }

    public Statistics() {
        this._transientTitlesPrint = false;
        _statisticsTitles = new TreeSet<>();
        _timeStatsRecorded = new TreeMap();
        _roundDecimal = DEFAULT_ROUND_DECIMAL;
    }

    /**
     * Checks if this statistic is recorded; if not, then it throws an
     * StatisticException
     *
     * @param statTitle
     * @throws StatisticException
     */
    private void checkName(String statTitle) throws StatisticException {
        if (!_statisticsTitles.contains(statTitle)) {
            throw new StatisticException(statTitle);
        }
    }

    /**
     * Checks if this statistic is recorded; if not, then it throws an
     * StatisticException
     *
     * @param statTitle
     * @param atTime
     * @throws StatisticException
     */
    private void checkName(String statTitle, int atTime) throws StatisticException {
        if (!_statisticsTitles.contains(statTitle)) {
            throw new StatisticException("Statistic value at time=" + atTime + ", for statistic title=" + statTitle + " does not exist."
                    + "\n"
                    + "Loaded statistic titles are: " + CommonFunctions.toString(_statisticsTitles)
                    + "");
        }
    }

    /**
     * @return the titles of the recorded statistics
     */
    public Set<String> getStatisticsTitles() {
        return Collections.unmodifiableSet(_statisticsTitles);
    }

    public SortedSet<Integer> times() {
        return Collections.unmodifiableSortedSet((SortedSet<Integer>) _timeStatsRecorded.keySet());
    }

    public void addTitle(String statTitle) {
        _statisticsTitles.add(statTitle);
    }

    @Override
    public final int simTime() {
        return getSim().simTime();
    }

    @Override
    public String simTimeStr() {
        return "[" + simTime() + "]";
    }

    @Override
    public final int simID() {
        return getSim().getID();
    }

    @Override
    public final SimulationBase getSim() {
        return _simulation;
    }

    @Override
    public final CellRegistry simCellRegistry() {
        return getSim().getCellRegistry();
    }

    public enum ConfidenceInterval {

        NONE("NONE", -1.0),
        Percentile_50("50%", 0.674),
        Percentile_60("60%", 0.842),
        Percentile_70("70%", 1.036),
        Percentile_80("80%", 1.282),
        Percentile_90("90%", 1.645),
        Percentile_95("95%", 1.96),
        Default("default", 1.96),
        Percentile_98("98%", 2.326),
        Percentile_99("99%", 2.576),
        Percentile_99_5("99.9%", 3.291);
        private final String confidencePercentile;
        private final double z;
        public static String defaultConfinceTooltip = Default.name() + " implies " + Percentile_95.confidencePercentile + " confidence";

        private ConfidenceInterval(String value, double z) {
            this.confidencePercentile = value;
            this.z = z;
        }

        public double z() {
            return z;
        }

        @Override
        public String toString() {
            return name() + ": <confidence level=" + confidencePercentile + ", z=" + z + ">";
        }

        /**
         * @param confidencePercentile e.g. "50%", "60%", .. "default", or by
         * name, e.g. "Percentile_50" or "Default"
         * @return
         */
        public static ConfidenceInterval find(String confidencePercentile) {
            for (ConfidenceInterval conf : ConfidenceInterval.values()) {
                if (conf.getConfidencePercentile().equals(confidencePercentile)) {
                    return conf;
                }
            }
            ConfidenceInterval conf = valueOf(confidencePercentile.trim());
            return null;
        }

        public static double getZFor(String name) {
            for (ConfidenceInterval conf : ConfidenceInterval.values()) {
                if (conf.getConfidencePercentile().equals(name)) {
                    return conf.z();
                }
            }
            return -1;
        }

        public String getConfidencePercentile() {
            return this.confidencePercentile;
        }
    };

    public String results__aggregated(
            boolean mean, boolean stddev, ConfidenceInterval confInterval, int minTime, int maxTime)
            throws StatisticException, InvalidOrUnsupportedException {

        StringBuilder _toString = new StringBuilder(1024);

        _toString.append(stats.utilities.CommonFunctions.toTitles_csvLine(
                _statisticsTitles, mean, stddev, confInterval)).append('\n');

        Couple<String, Values>[] aggregatesForMean = mean(_statisticsTitles, minTime, maxTime);
        _toString.append(stats.utilities.CommonFunctions.toStatValues_csvLine(
                aggregatesForMean, mean, stddev, confInterval)).append('\n');// 
//      _toString.append(CommonFunctions.toStatValues_csvLine(_statisticsTitles, mean, stddev, confIntervals)).append('\n');// titles

        return _toString.toString();
    }

    public String resultsTransient(boolean prinAll,
            boolean mean, boolean stddev, ConfidenceInterval confInterval) throws StatisticException {
        StringBuilder sb = new StringBuilder(1024);

        if (!_transientTitlesPrint) {
            sb.append("Time,").append(stats.utilities.CommonFunctions.toTitles_csvLine(
                    _statisticsTitles, mean, stddev, confInterval)).append('\n');
            _transientTitlesPrint = true;
        }
        
        if (!prinAll) {
            return sb.append(
                    resultsTransientMostRecent(mean, stddev, confInterval)
            ).toString();
        }
        

        Set<Integer> timesSet = _timeStatsRecorded.keySet();
        Iterator<Integer> timesIter = timesSet.iterator();
        while (timesIter.hasNext()) {
            Integer nxt_time = timesIter.next();

            StatsToValuesMapping recordedAt_nxt_Time = _timeStatsRecorded.get(nxt_time);
            String csvLine = recordedAt_nxt_Time.toString_csv(mean, false, stddev, confInterval, _statisticsTitles, false);
            // add simTime followed by csv values
            sb.append(nxt_time).append(',').append(csvLine).append("\n");
        }
        return sb.toString();
    }

    private String resultsTransientMostRecent(
            boolean mean, boolean stddev, ConfidenceInterval confInterval) throws StatisticException {
        StringBuilder sb = new StringBuilder(1024);

        Integer mostRecentTime = _timeStatsRecorded.lastKey();

        StatsToValuesMapping recordedAt_nxt_Time = _timeStatsRecorded.get(mostRecentTime);
        String csvLine = recordedAt_nxt_Time.toString_csv(mean, false, stddev, confInterval, _statisticsTitles, false);
        // add simTime followed by csv values
        sb.append(mostRecentTime).append(',').append(csvLine).append("\n");

        return sb.toString();
    }

    public void addValuesForTime(int time, String statTitle, double... value) {
        // ensure record exists in map
        StatsToValuesMapping titles_values;
        if ((titles_values = _timeStatsRecorded.get(time)) == null) {
            titles_values = new StatsToValuesMapping();
            _timeStatsRecorded.put(time, titles_values);
        }
        // in any case addValuesForTime for statTitle, and if first simTime added, ensure recorded in knwon names ..
        titles_values.update(statTitle, _roundDecimal, value);
        _statisticsTitles.add(statTitle);
    }

    public void addValuesForTime(int time, StatsToValuesMapping titles_values) {
        if (null != (_timeStatsRecorded.put(time, titles_values))) {
            throw new UnsupportedOperationException("A record allready exists for the particular time in statistics");
        }

        _statisticsTitles.addAll(titles_values.getTitles());
    }

    /**
     * Invoke this method to finalize and compress state in memory for the given
     * simulation simTime. State is compressed in the sense that discrete values
     * become garbage collectable.
     *
     * State finalization implies that after invoking this method you cannot
     * record more values for this simTime; otherwise the aggregated results
     * returned are inaccurate and the overall behavior undefined.
     *
     * @param time
     *
     */
    public void finalizeState(int time) {
        // ensure record exists in map
        StatsToValuesMapping recs;
        if ((recs = _timeStatsRecorded.get(time)) == null) {
            throw new InconsistencyException("Illegal action:"
                    + " Trying to finalize statistics record for time " + time + " that is not recorded."
            );
        }
        recs.ensureTitles(_statisticsTitles);
        recs.finalizeState();

    }

    public Values aggregates(String statTitle, int atTime) throws StatisticException {
        checkName(statTitle, atTime);
        StatsToValuesMapping rec = _timeStatsRecorded.get(atTime);
        if (rec == null) {
            throw new StatisticException(statTitle + " is not present in file");
        }
        return rec.aggregatesFor(statTitle);
    }

    /**
     * @param statTitles
     * @param startTime starting from this simTime up until the end
     * @return a list in which each next element contains an array of (name,
     * aggregates) couples, with next list element referencing the next simTime
     * period.
     */
    public List<Couple<String, Values>[]> aggregates(int startTime, Collection<String> statTitles) {
        List<Couple<String, Values>[]> _aggregates = new ArrayList<>();

        // for every simTime-record entry
        for (Map.Entry<Integer, StatsToValuesMapping> entry : _timeStatsRecorded.entrySet()) {
            Integer nxt_time = entry.getKey();
            if (nxt_time < startTime) {
                continue;
            }

            StatsToValuesMapping rec_atTime = entry.getValue();
            Iterator<String> statTitle_iter = statTitles.iterator();
            Couple<String, Values>[] coupleArray = new Couple[statTitles.size()];
            // for every aggregate per stat title
            int i = 0;
            while (statTitle_iter.hasNext()) {
                String statTitle = statTitle_iter.next();
                coupleArray[i++] = new Couple(statTitle, rec_atTime.aggregatesFor(statTitle));
            }
            _aggregates.add(coupleArray);
        }
        return _aggregates;
    }

    /**
     * @param statTitles
     * @param atTime
     * @return an array of (title, aggregates) couples for simTime atTime.
     * @throws stats.StatisticException
     */
    public Couple<String, Values>[] statTitle_aggregates(Collection<String> statTitles, int atTime)
            throws StatisticException {
        Couple<String, Values>[] _statTitle_aggregates = new Couple[statTitles.size()];

        StatsToValuesMapping rec_atTime = _timeStatsRecorded.get(atTime);
        Iterator<String> statTitle_iter = statTitles.iterator();
        int i = 0;
        while (statTitle_iter.hasNext()) {
            String statTitle = statTitle_iter.next();
            Values aggr = rec_atTime.aggregatesFor(statTitle);
            if (aggr == null) {
                throw new StatisticException(
                        "There is no record kept for statistic \"" + statTitle + "\" at time " + atTime);
            }
            _statTitle_aggregates[i++] = new Couple(statTitle, aggr);
        }
        return _statTitle_aggregates;
    }

    /**
     * @param statTitle the title of a particular statistic title
     * @return mean value in aggregates per each simTime
     * @throws stats.StatisticException
     * @throws epc.femto.exceptions.InvalidOrUnsupportedException
     */
    public Values mean(String statTitle) throws StatisticException, InvalidOrUnsupportedException {
        checkName(statTitle);
        Values _aggregatesForMean = new Values(_roundDecimal);
        boolean nonFound = true;

        // for every simTime
        for (Map.Entry<Integer, StatsToValuesMapping> entry : _timeStatsRecorded.entrySet()) {
            // get aggregate for certain stat
            Values nxtTime_aggr = entry.getValue().aggregatesFor(statTitle);
            if (nxtTime_aggr != null) {
                _aggregatesForMean.updt(nxtTime_aggr.mean());
                nonFound = false;
            }
        }

        return nonFound ? null : _aggregatesForMean;
    }

    public Couple<String, Values>[] aggregatesForMean(Collection<String> statTitles)
            throws StatisticException, InvalidOrUnsupportedException {
        Couple<String, Values>[] _aggregatesForMean_arr = new Couple[statTitles.size()];
        int i = 0;
        for (String nxt_stat : statTitles) {
            Values nxt_statAggr = mean(nxt_stat);
            _aggregatesForMean_arr[i++] = new Couple<>(nxt_stat, nxt_statAggr);
        }
        return _aggregatesForMean_arr;
    }

    /**
     *
     * @param statTitle
     * @param fromTime start aggregating from this simTime and on
     * @return mean value in aggregates per each simTime
     * @throws stats.StatisticException
     * @throws epc.femto.exceptions.InvalidOrUnsupportedException
     */
    public Values mean(String statTitle, int fromTime)
            throws StatisticException, InvalidOrUnsupportedException {
        checkName(statTitle);
        Values _aggregatesForMean = new Values(_roundDecimal);

        for (Map.Entry<Integer, StatsToValuesMapping> entry : _timeStatsRecorded.entrySet()) {
            if (entry.getKey() < fromTime) {
                continue;
            }

            Values nxtTime_aggr = entry.getValue().aggregatesFor(statTitle);
            if (nxtTime_aggr != null) {
                _aggregatesForMean.updt(nxtTime_aggr.mean());
            }
        }

        return _aggregatesForMean;
    }

    public Couple<String, Values>[] mean(Collection<String> statTitles, int minTime)
            throws StatisticException, InvalidOrUnsupportedException {
        Couple<String, Values>[] _aggregatesForMean_arr = new Couple[statTitles.size()];
        int i = 0;
        for (String nxt_stat : statTitles) {
            Values nxt_statAggr = mean(nxt_stat, minTime);
            _aggregatesForMean_arr[i++] = new Couple<>(nxt_stat, nxt_statAggr);
        }
        return _aggregatesForMean_arr;
    }

    /**
     *
     * @param statTitle
     * @param fromTime start aggregating from this simTime and on
     * @param maxTime stop aggregating after this max simTime threshold
     * @return aggregates with respect to the recorded mean value in aggregates
     * per each simTime
     * @throws stats.StatisticException
     * @throws epc.femto.exceptions.InvalidOrUnsupportedException
     */
    public Values mean(String statTitle, int fromTime, int maxTime)
            throws StatisticException, InvalidOrUnsupportedException {
        checkName(statTitle);
        Values _aggregatesForMean = new Values(_roundDecimal);

        for (Map.Entry<Integer, StatsToValuesMapping> entry : _timeStatsRecorded.entrySet()) {
            if (entry.getKey() < fromTime) {
                continue;
            }
            if (entry.getKey() > maxTime) {
                break;
            }

            Values nxtTime_aggr = entry.getValue().aggregatesFor(statTitle);
            if (nxtTime_aggr != null) {
                _aggregatesForMean.updt(nxtTime_aggr.mean());
            }
        }

        return _aggregatesForMean;
    }

    public Couple<String, Values>[] mean(Collection<String> statTitles, int minTime, int maxTime)
            throws StatisticException, InvalidOrUnsupportedException {
        Couple<String, Values>[] _aggregatesForMean_arr = new Couple[statTitles.size()];
        int i = 0;
        for (String nxt_stat : statTitles) {
            Values nxt_statAggr = mean(nxt_stat, minTime, maxTime);
            _aggregatesForMean_arr[i++] = new Couple<>(nxt_stat, nxt_statAggr);
        }
        return _aggregatesForMean_arr;
    }

    @Override
    public String toString() {
        StringBuilder _toString = new StringBuilder();
        // print titles
        _toString.append("TIME,").append(util.CommonFunctions.toString("", "", "", ",", _statisticsTitles)).append('\n');

        //<editor-fold defaultstate="collapsed" desc="fr every pair of simTime and <stat, value>">
        for (Map.Entry<Integer, StatsToValuesMapping> entry : _timeStatsRecorded.entrySet()) {
            Integer time = entry.getKey();
            StatsToValuesMapping stats2Values = entry.getValue();

            _toString.append(time).append(',');// append simTime

            //<editor-fold defaultstate="collapsed" desc="append value for every title">
            Iterator<String> iterator = _statisticsTitles.iterator();
            while (iterator.hasNext()) {
                String statTitle = iterator.next();
                try {
                    _toString.append(stats2Values.mean(statTitle)).append(',');
                } catch (StatisticException ex) {
                    throw new RuntimeException(ex);
                }
            }
            //</editor-fold>

            _toString.append('\n');
        }
//</editor-fold>

        return _toString.toString();

    }
}
