package caching.rplc.mingain.no_price;

import caching.Utils;
import caching.base.AbstractCachingPolicy;
import exceptions.InconsistencyException;
import java.util.PriorityQueue;
import java.util.Set;
import sim.space.cell.smallcell.BufferBase;
import sim.space.cell.smallcell.SmallCell;
import sim.SimulationBase;
import sim.content.Chunk;
import sim.space.users.CachingUser;
import util.DebugUtils;

/**
 * Efficient proactive caching with legacy popularity, using a least gain cache
 * replacement policy defined in class AbstractGainRplc. Unlike MinGainAvgProb,
 * this class implementation uses the sum of transition probabilities for
 * assessing the weighted delay gain of a cache decision.
 *
 * @author Xenofon Vasilakos xvas@aueb.gr
 */
public class EMC_LC_Full extends caching.rplc.mingain.EMC_LC_Full_Priced {

    private static final AbstractCachingPolicy singelton = new EMC_LC_Full();

    public static AbstractCachingPolicy instance() {
        return singelton;
    }

    public EMC_LC_Full() {
    }

    @Override
    public int cacheDecision(SimulationBase sim, CachingUser mu,
            Iterable<Chunk> requestChunks, SmallCell hostSC,
            SmallCell targetSC, Set<Chunk> chunksRplcd,
            PriorityQueue<Chunk> cachedOrderByGain) throws Throwable {

        int totalSizeCached = 0;
        for (Chunk nxtChunk : requestChunks) {

            double assessment = assess(nxtChunk, targetSC) / nxtChunk.sizeInMBs();// due to polymorphism, assess may be different in sub classes
            if (assessment == 0
                    && !Utils.isSpaceAvail(this, targetSC, nxtChunk.sizeInBytes())) {
                continue;
            }

            if (targetSC.isCached(this, nxtChunk)) {
                targetSC.addCacher(mu, this, nxtChunk);
                continue;
            }// otherwise, it may need to evict:

            if (!Utils.isSpaceAvail(this, targetSC, nxtChunk.sizeInBytes())) {
                //<editor-fold defaultstate="collapsed" desc="if not available space, evict!">
                /*
                 * Try evicting items
                 */
                Set<Chunk> opt4Eviction = optForEviction(targetSC, nxtChunk,
                        cachedOrderByGain);

                if (opt4Eviction.isEmpty()) {
                    continue;//cannot add this item
                }

                for (Chunk items2evict : opt4Eviction) {
                    targetSC.bufferForceEvict(this, items2evict);
                    chunksRplcd.add(items2evict);
                    cachedOrderByGain.remove(nxtChunk);
                }
                //</editor-fold>
            }// if not available space

            totalSizeCached += nxtChunk.sizeInBytes();

            targetSC.cacheItem(mu, this, nxtChunk);
            cachedOrderByGain.add(nxtChunk);
            targetSC.cachePriceUpdt4Rplc(this);
        }
        return totalSizeCached;
    }

}
