package stats.output.aggregating;

import java.awt.BorderLayout;
import java.awt.GridLayout;
import java.awt.HeadlessException;
import java.io.File;
import java.io.IOException;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Set;
import java.util.SortedSet;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.AbstractButton;
import javax.swing.ButtonGroup;
import javax.swing.JFileChooser;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JRadioButton;
import javax.swing.filechooser.FileFilter;
import stats.StatisticException;
import stats.Statistics;
import stats.Values;
import stats.output.Constants;
import static stats.output.Constants.DEFAULT_STATS_PATH;
import static stats.output.Constants.MODE__AGGREGATES_STATS;
import static stats.output.Constants.MODE__TRANSIENT_STATS;
import static stats.output.Constants.SCENARIO_SETUP_BEGIN;
import static stats.output.Constants.SCENARIO_SETUP_END;
import static stats.output.Constants.TIME;
import util.CommonFunctions;

/**
 *
 * @author Xenofon Vasilakos xvas@aueb.gr
 */
public class AggregatorApp {

   private static boolean printMean = true;
   private static boolean printStdev = true;
   private static int roundDecimal = 5;
   //////////////// aggrRpts varibles ////////////
   /**
    * which statistic titles to keep
    */
   private static Set<String> statTitles = new HashSet<>(Arrays.asList(
         new String[]{ //<editor-fold defaultstate="collapsed" desc="stats.handlers.iterative.mu.handover.**.TITLE">
         //         stats.handlers.iterative.mu.handover.EPC_Gain.TITLE 
         //</editor-fold>
         }));
   /**
    * Different param values for the params in this set are ignored when merging different
    * scenarios setups, i.e. if the rest params have same values, then the two setups are
    * merged same group, neglecting difference with respect to members of this set. The
    * stats printed underneeth each resulting group thow are differenciated per scenario
    * setup by using the ignored param value with each stat title.
    */
   private static Set<String> grping__ignoredParams = new TreeSet<>(Arrays.asList(
         new String[]{
            "TU",
            "beta"
         //         "#SCs",
         //      "mu_delay"
         //            "probs_policy",
         //            "#MUs_tot"
         }));

   private static void userAbortedMsg() {
      JOptionPane.showMessageDialog(null, "You have chosen to Abort", "Aborting", JOptionPane.INFORMATION_MESSAGE);
   }

   private static void printRes__aggregated__mean(Set<String> statTitles, SetupsGrp nxt_grp, Integer nxt_time,
         PrintStream printer, int _roundDecimal) throws StatisticException {
      /*
       * Aggregate values from all files, for nxt_time, to a Values instance. 
       * Use an array of Values instances, one per each title to print.
       */
      Values[] aggrFilesValues = new Values[statTitles.size()];
      for (int i = 0; i < aggrFilesValues.length; i++) {
         aggrFilesValues[i] = new Values(_roundDecimal); /*aggregates values from all files, for nxt_time*/

      }

      /* 
       - for each result file in the next group, aggregate and then print the values about:  
       *  -- (i) the statistic title for the next time
       */
      Set<ResultsFile> groupMembers = nxt_grp.members();
      FOR_RESULT_FILE:
         for (ResultsFile nxtResFile : groupMembers) {

            int i = 0; // index to aggrFilesValues for the i-th stat title
            for (String nxt_statTitle : statTitles) {
               Values aggrVal = null;

               try {
                  aggrVal = nxtResFile.getStatistics().aggregates(nxt_statTitle, nxt_time);/* Aggregates from one file, for all records for nxt_time*/
               } catch (StatisticException e) {
                  Logger.getGlobal().log(Level.WARNING,
                        " File " + nxtResFile.getFilePath()
                        + " faces issues and will be ignored.",
                        e);
                  continue FOR_RESULT_FILE;
               }
               if (aggrVal == null) {
                  Logger.getGlobal().log(Level.WARNING,
                        "{0} has probably no record for time {1}."
                        + " File {2} will be ignored.",
                        new Object[]{
                           nxt_statTitle, nxt_time, nxtResFile.getFilePath()
                        });
                  continue FOR_RESULT_FILE;
               }

               double mean = aggrVal.mean();
               aggrFilesValues[i++].updt(mean);
            }//for i-th stat title
         }// for grp mebers

      // now print aggregate values
      for (Values statValue : aggrFilesValues) {
         if (statValue == null) {
            printer.print(",");
         } else {
            printer.print(statValue.mean());
         }
         printer.print(',');
      }//for
   }

   private static void printRes__aggregated__confidence(Set<String> statTitles, SetupsGrp nxt_grp,
         Integer nxt_time, Statistics.ConfidenceInterval confidenceLevel, PrintStream printer) throws StatisticException {
      /*
       * Aggregate values from all files, for nxt_time, to a Values instance. 
       * Use an array of Values instances, one per each title to print.
       */
      Values[] aggrFilesValues = new Values[statTitles.size()];
      for (int i = 0; i < aggrFilesValues.length; i++) {
         aggrFilesValues[i] = new Values(roundDecimal); /*aggregates values from all files, for nxt_time*/

      }

      /* 
       - for each result file in the next group, aggregate and then print the values about:  
       *  -- (i) the statistic title for the next time
       */
      Set<ResultsFile> groupMembers = nxt_grp.members();
      FOR_RESULTS_FILE:
         for (ResultsFile nxtResFile : groupMembers) {

            int i = 0; // index to aggrFilesValues for the i-th stat title
            for (String nxt_statTitle : statTitles) {
               Values aggrVal = nxtResFile.getStatistics().aggregates(nxt_statTitle, nxt_time);/*aggregates from one file, for all records for nxt_time*/

               if (aggrVal == null) {
                  Logger.getGlobal().log(Level.WARNING,
                        "There is no record for {0} in file {1}. "
                        + "File will be ignored",
                        new Object[]{
                           nxt_statTitle, nxtResFile.getFilePath()
                        });
                  continue FOR_RESULTS_FILE;
               }

               aggrFilesValues[i++].updt(aggrVal.mean());
            }//for i-th stat title
         }// for grp mebers

      // now print aggregate values
      for (Values statValue : aggrFilesValues) {
         if (statValue == null) {
            printer.print(",");
         } else {
            printer.print(statValue.absConfInterval(confidenceLevel.z()));
         }
         printer.print(',');
      }//for
   }

   private static void printRes__aggregated__stdev(Set<String> statTitles, SetupsGrp nxt_grp, Integer nxt_time, PrintStream printer) throws StatisticException {
      /*
       * Aggregate values from all files, for nxt_time, to a Values instance. 
       * Use an array of Values instances, one per each title to print.
       */
      Values[] aggrFilesValues = new Values[statTitles.size()];
      for (int i = 0; i < aggrFilesValues.length; i++) {
         aggrFilesValues[i] = new Values(roundDecimal); /*aggregates values from all files, for nxt_time*/

      }

      /* 
       - for each result file in the next group, aggregate and then print the values about:  
       *  -- (i) the statistic title for the next time
       */
      Set<ResultsFile> groupMembers = nxt_grp.members();
      for (ResultsFile nxt_resFile : groupMembers) {

         int i = 0; // index to aggrFilesValues for the i-th stat title
         for (String nxt_statTitle : statTitles) {
            Values aggrVal = nxt_resFile.getStatistics().aggregates(nxt_statTitle, nxt_time);/*aggregates from one file, for all records for nxt_time*/

            aggrFilesValues[i++].updt(aggrVal.mean());
         }//for i-th stat title
      }// for grp mebers

      // now print aggregate values
      for (Values statValue : aggrFilesValues) {
         if (statValue == null) {
            printer.print(",");
         } else {
            printer.print(statValue.stddev());
         }
         printer.print(',');
      }//for
   }

   public static void main(String[] args) throws IOException, StatisticException {
      JFileChooser jchosser = selectFiles(DEFAULT_STATS_PATH, true, "Group results from different scenarios.", "Group");    // asks user
      ResultsFile[] resultsFiles = parseResultsFiles(statTitles, jchosser.getSelectedFiles(), true, -1);

      //<editor-fold defaultstate="collapsed" desc="String aggrResults parent path and file name">
       /*
       * Parent path:   The same as with the partent directory of first file from the selected files.
       */
      String aggrResults__parentPath = jchosser.getSelectedFile().getParentFile().getCanonicalPath();

      /* 
       * File name:     Constructed after the titles included in statTitlesFilter
       */
      String aggrResults__FileName = jchosser.getSelectedFile().getParentFile().getName() + "_"
            + CommonFunctions.toString("", "", "", "_", statTitles)
            //+ "_" + new SimpleDateFormat("y-M-dd_HH-mm").format(Calendar.getInstance().getTime())
            + ".csv";
      //</editor-fold>

      String pathOut = aggrResults__parentPath + "/" + aggrResults__FileName;
//      confidenceLevel = chooseConfidenceInterval();             // asks use
      aggrRpts(statTitles, resultsFiles, pathOut, true, printMean, printStdev, Statistics.ConfidenceInterval.NONE);
      grpScenarios(statTitles, grping__ignoredParams, resultsFiles, pathOut, true, printMean, printStdev, false);
   }

   /**
    * Aggregates the results from different repeats of the same scenario setup, i.e.
    * setups with different seed, and prints them into a file.
    *
    * The statistics printed are the ones included in the grping__statTitles, and
    * aggregated together under each group of results. Groups of results stem from the
    * same scenario parameter setup (all parameters have the same value), but from from
    * different repeats (different seed parameter).
    *
    * @param statTitles
    * @param resultsFiles
    * @param aggrResultsPath
    * @param printMean
    * @param printStdev
    * @param transientResults
    * @param confidenceLevel
    * @throws IOException
    * @throws StatisticException
    */
   public static void aggrRpts(Set<String> statTitles, ResultsFile[] resultsFiles, String aggrResultsPath,
         boolean transientResults, boolean printMean, boolean printStdev, Statistics.ConfidenceInterval confidenceLevel)
         throws IOException, StatisticException {

      Set<String> ignoreRpts = new HashSet<>(1);
      ignoreRpts.add(app.properties.valid.Values.SEED_RPT);       // ignore different repeats when differenciating groups
      Set<SetupsGrp> resultsGrouped = groupRFs(resultsFiles, ignoreRpts);

      //<editor-fold defaultstate="collapsed" desc="logging INFO to user">
      String logMsg = "==== INFO ===="
            + "\n\t- Results files processed: {0}"
            + "\n\t- Groups of results: {1}"
            + "\n\t- Output in path: {2}";

      Object[] msgArr = new Object[]{
         resultsFiles.length,
         resultsGrouped.size(),
         aggrResultsPath
      };
      logInfo(logMsg, msgArr);
      //</editor-fold>

      //<editor-fold defaultstate="collapsed" desc="print to output file">
      try (PrintStream printer = new PrintStream(aggrResultsPath)) {
         //<editor-fold defaultstate="collapsed" desc="Decide how many times a gap for a title is printed">
         int gaps = 1;// at least one gap to separate different groups of results files
         if (printMean) {
            gaps++;
         }
         if (printStdev) {
            gaps++;
         }
         gaps *= statTitles.size();
         //</editor-fold>

         printGroups(resultsGrouped, printer, transientResults, gaps);
         printer.println();
         printTitles__perGrp(transientResults, resultsGrouped, statTitles, null, printer, printMean, printStdev, confidenceLevel);
         printRes__aggregated(transientResults ? resultsFiles[0].times() : null, resultsGrouped, statTitles, printer, printMean, printStdev, confidenceLevel);
      }
      //</editor-fold>
   }

   /**
    * Grouping the results from the same or different scenario setups, and prints them
    * into a file.
    *
    * The statistics printed are the ones included in the statTitles parameter, and
    * grouped under each group of setups. Setups are grouped together based on common
    * parameter values, excluding any setup parameters with different values included in
    * the ignoredParams set.
    *
    * @param statTitles
    * @param ignoredParams
    * @param resultsFiles
    * @param aggrResults__path
    * @param printTime
    * CAUTION Different repeats of the same setup will be grouped together. It is advised
    * to run aggrRpts() first and then apply this method on the aggregated result files.
    *
    * @throws IOException
    * @throws StatisticException
    */
   public static void grpScenarios(Set<String> statTitles, Set<String> ignoredParams, ResultsFile[] resultsFiles,
         String aggrResults__path, boolean printTime,
         boolean printMean, boolean printStdev, boolean printConfidenceLevel)
         throws IOException, StatisticException {

      Set<SetupsGrp> resultsGrouped = groupRFs(resultsFiles, ignoredParams);

      //<editor-fold defaultstate="collapsed" desc="logging INFO to user">
      String logMsg = "==== INFO ===="
            + "\n\t- Results files processed: {0}"
            + "\n\t- Groups of results: {1}"
            + "\n\t- Output in path: {2}";

      Object[] msgArr = new Object[]{
         resultsFiles.length,
         resultsGrouped.size(),
         aggrResults__path
      };
      logInfo(logMsg, msgArr);
      //</editor-fold>

      //<editor-fold defaultstate="collapsed" desc="print to output file">
      try (PrintStream printer = new PrintStream(aggrResults__path)) {
         //<editor-fold defaultstate="collapsed" desc="Decide gaps between grouped results">
         int gaps = 1; // at least one empty gap between different groups
         if (printMean) {
            gaps++;
         }
         if (printStdev) {
            gaps++;
         }
         if (printConfidenceLevel) {
            gaps++;
         }
         gaps *= ignoredParams.size();
         gaps *= statTitles.size();
         //</editor-fold>
         printGroups(resultsGrouped, printer, printTime, gaps);
         printer.println();
         printTitles__perResFilePerGrp(printTime, resultsGrouped, statTitles, ignoredParams, printer);
         SortedSet<Integer> times2print = printTime ? resultsFiles[0].times() : null;
         printRes__perResFilePerGrp(times2print, resultsGrouped, statTitles, printer);
      }
      //</editor-fold>
   }

   public static void printGroups(Set<SetupsGrp> resultsGrouped, PrintStream printer,
         boolean printTime, int gaps) {

      Iterator<SetupsGrp> resultsGrouped_iter = resultsGrouped.iterator();

      while (resultsGrouped_iter.hasNext()) {
         SetupsGrp nxt_grp = resultsGrouped_iter.next();
         //<editor-fold defaultstate="collapsed" desc="if (firstGrpPrinting)">
         if (printTime) {// print only one comma before printing the first group
            printer.append(",");
            printTime = false; // print only one comma before printing the first group
         }
         //</editor-fold>

         printer.append('"'); // needed for excel multiline within cell 
         printer.append(SCENARIO_SETUP_BEGIN);
         printer.append('\n');
         printer.append(nxt_grp.scenarioSetup());
         printer.append('\n');
         printer.append(SCENARIO_SETUP_END);
         printer.append('"');

         // print gaps for titles in the row to be printed below the group's setup
         for (int i = 0; i < gaps; i++) {
            printer.print(",");
         }
      }
   }

   /**
    *
    *
    * @param times
    * @param resultsGrouped
    * @param statTitles
    * @param printer
    */
   public static void printRes__perResFilePerGrp(
         SortedSet<Integer> times, Set<SetupsGrp> resultsGrouped,
         Set<String> statTitles, PrintStream printer) throws StatisticException {

      //<editor-fold defaultstate="collapsed" desc="if times is null">
      boolean mokeTimes = false;
      if (times == null) { // this is because the results are from aggregated results per simulation run, with no times printed
         times = new TreeSet<>();//create a moke time
         times.add(-1000);
         mokeTimes = true;
      }
      //</editor-fold>

      for (Integer nxt_time : times) {
         // print the time first
         if (!mokeTimes) {
            printer.print(nxt_time);
            printer.print(',');
         }
         /* 
          * for each next group:
          * - for each result file in the next group, print the value about:  
          *  -- (i) the statistic title (ii) for the next time
          */
         Iterator<SetupsGrp> resultsGrouped_iter = resultsGrouped.iterator();
         while (resultsGrouped_iter.hasNext()) {
            SetupsGrp nxt_grp = resultsGrouped_iter.next();

            /* 
             * for each result file in the next group, print the value about:  
             *  - (i) the statistic title (ii) for the next time
             */
            Set<ResultsFile> groupMembers = nxt_grp.members();
            for (ResultsFile nxt_resFile : groupMembers) {
               for (String nxt_statTitle : statTitles) {
                  Values aggrVal = nxt_resFile.getStatistics().aggregates(nxt_statTitle, nxt_time);
                  if (aggrVal == null) {
                     printer.print(",");
                  } else {
                     printer.print(aggrVal.mean());
                  }
                  printer.print(',');
               }
            }
            printer.print(",");// to seprate between results from differet goups
         }
         printer.println();
      }
   }

   public static void printRes__aggregated(
         SortedSet<Integer> times, Set<SetupsGrp> resultsGrouped,
         Set<String> statTitles, PrintStream printer,
         boolean mean, boolean stdev, Statistics.ConfidenceInterval confLvl) throws StatisticException {

      //<editor-fold defaultstate="collapsed" desc="if times is false">
      boolean noTimes_noTransientRes = false;
      if (times == null) { /* this is because the results are from aggregated 
          * (not transient) results per simulation run, thus with no times printed
          */

         times = new TreeSet<>();//create a moke time
         times.add(Constants.AGGR_RESULTS_FILE__DEFAULT_TIME);
         noTimes_noTransientRes = true;
      }
      //</editor-fold>

      for (Integer nxt_time : times) {
         if (!noTimes_noTransientRes) { // print the time first if transient results
            printer.print(nxt_time);
            printer.print(',');
         }

         /* 
          * for each group of ResultFile instances:
          * - for each result file in the next group, aggregate and then print the values about:  
          *  -- (i) the statistic title for the next time
          */
         Iterator<SetupsGrp> resultsGrouped_iter = resultsGrouped.iterator();
         while (resultsGrouped_iter.hasNext()) {
            SetupsGrp nxt_grp = resultsGrouped_iter.next();
            if (mean) {
               printRes__aggregated__mean(statTitles, nxt_grp, nxt_time, printer, roundDecimal);
            }
            if (confLvl != Statistics.ConfidenceInterval.NONE) {
               printRes__aggregated__confidence(statTitles, nxt_grp, nxt_time, confLvl, printer);
            }
            if (stdev) {
               printRes__aggregated__stdev(statTitles, nxt_grp, nxt_time, printer);
            }

         }
         printer.println();
      }
   }

   /**
    * Prints the titles of statistics for each ignored setup parameter. Results from
    * different setups are grouped together, thus the title of each statistics is repeated
    * for each different setup parameter value.
    *
    * @param printTimes
    * @param resultsGrouped
    * @param statTitles
    * @param ignoredSetupParams
    * @param printer
    * @throws StatisticException
    */
   public static void printTitles__perResFilePerGrp(
         boolean printTimes, Set<SetupsGrp> resultsGrouped,
         Set<String> statTitles,
         Set<String> ignoredSetupParams,
         PrintStream printer) throws StatisticException {

      // print ,the time first
      if (printTimes) {
         printer.print(TIME);
         printer.print(',');
      }

      Iterator<SetupsGrp> resultsGrouped_iter = resultsGrouped.iterator();
      while (resultsGrouped_iter.hasNext()) {
         SetupsGrp nxt_grp = resultsGrouped_iter.next();

         /* 
          * For each results file in the next group:
          * - print the title about the statistic title + grouping ignored parameter 
          */
         Set<ResultsFile> groupMembers = nxt_grp.members();
         for (ResultsFile nxt_resFile : groupMembers) {
            /* 
             * for every ignored parameter, find their value in the results file
             */
            StringBuilder paramVals = new StringBuilder();
            for (String ignoredParam : ignoredSetupParams) {
               paramVals.append(ignoredParam).append('=');
               paramVals.append(nxt_resFile.getSetupParam(ignoredParam).getValue());
            }
            String paramVals_str = paramVals.toString();
            for (String nxtTitle : statTitles) {
               printer.print(nxtTitle);
               if (!paramVals_str.isEmpty()) {
                  printer.print("-" + paramVals_str);
               }
               printer.print(',');
            }
         }// For each results file in the next group

         printer.print(',');// print an extra comma gap to separate between groups.

      }
      printer.println();
   }

   /**
    * Prints the titles once per group. Titles are printed for mean, stdev, and conf.
    * interval is the latter are to be printed.
    *
    * @param printTimes
    * @param resultsGrouped
    * @param statTitles
    * @param ignoredSetupParams
    * @param printer
    * @throws StatisticException
    */
   public static void printTitles__perGrp(
         boolean printTimes, Set<SetupsGrp> resultsGrouped,
         Set<String> statTitles,
         Set<String> ignoredSetupParams,
         PrintStream printer, boolean mean, boolean stdev, Statistics.ConfidenceInterval confLvl) throws StatisticException {

      // print ,the time first
      if (printTimes) {
         printer.print(TIME);
         printer.print(',');
      }

      Iterator<SetupsGrp> resultsGrouped_iter = resultsGrouped.iterator();
      while (resultsGrouped_iter.hasNext()) {
         resultsGrouped_iter.next();
         //<editor-fold defaultstate="collapsed" desc=" if (mean)">
         if (mean) {
            for (String nxt_statTitle : statTitles) {
               printer.print(nxt_statTitle);
//                    printer.print("(mean)");
               printer.print(',');

            }
         }
         //</editor-fold>
         //<editor-fold defaultstate="collapsed" desc=" if (stdev)">
         if (stdev) {
            for (String nxt_statTitle : statTitles) {
               printer.print(nxt_statTitle);
               printer.print("(stdev)");
               printer.print(',');
            }
         }
         //</editor-fold>
         //<editor-fold defaultstate="collapsed" desc=" if(confLvl != Statistics.ConfidenceInterval.NONE)">
         if (confLvl != Statistics.ConfidenceInterval.NONE) {
            for (String nxt_statTitle : statTitles) {
               printer.print(nxt_statTitle);
               printer.print("(" + confLvl.getConfidencePercentile() + ")");
               printer.print(',');
            }
         }
         //</editor-fold>
         if (resultsGrouped_iter.hasNext()) { // if there is a next group, print a gap (empty) column
            printer.print(',');
         }
      }
      printer.println();
   }

   public static ResultsFile[] parseResultsFiles(
         Set<String> statTitlesFilter, File[] selectedFiles, boolean statsTransientMode, int skipUntilTime)
         throws IOException {

      List<ResultsFile> resultsFiles = new ArrayList<>();
      int pos = 0;
      for (File nxt_file : selectedFiles) {
         if (!nxt_file.getName().endsWith(".csv")) {
            Logger.getLogger(AggregatorApp.class.getName()).log(Level.WARNING,
                  "File not recognised by name suffix as a csv resaults file and "
                        + "will be ignored: "
                  + nxt_file.getCanonicalFile()
            );
            continue;
         }
         try {
            ResultsFile rf
                  = ResultsFileParser.parse(
                        statTitlesFilter, nxt_file,
                        statsTransientMode ? MODE__TRANSIENT_STATS : MODE__AGGREGATES_STATS, skipUntilTime
                  );
            resultsFiles.add(rf);
         } catch (IOException | NumberFormatException | ResultFileMalformedException | UnsupportedOperationException whatewver) {
            Logger.getLogger(AggregatorApp.class.getName()).log(Level.WARNING,
                  "File failed in parssing and will be ignored: "
                  + nxt_file.getCanonicalFile(),
                  whatewver.getMessage()
            );
//            Logger.getGlobal().log(Level.SEVERE, "File failed in parssing and will be ignored: " + nxt_file.getCanonicalFile(), whatewver);
         }
      }
      return resultsFiles.toArray(new ResultsFile[resultsFiles.size()]);
   }

   public static Statistics.ConfidenceInterval chooseConfidenceInterval() throws HeadlessException {
      /* one radio button for each confidence interval enum category*/
      Statistics.ConfidenceInterval[] confidenceLevels = Statistics.ConfidenceInterval.values();

      //<editor-fold defaultstate="collapsed" desc="jpanels with message content and radios for the optionpane">
      JPanel msgPanel = new JPanel(new BorderLayout()); // panel with message on north and radios on south
      msgPanel.add(new JLabel("Choose a confidence level out of the following:"), BorderLayout.NORTH);

      JPanel confidenceRadiosPanel = new JPanel(new GridLayout(confidenceLevels.length / 3, 3)); // subpanel of radios
      msgPanel.add(confidenceRadiosPanel, BorderLayout.SOUTH);

      confidenceRadiosPanel.setToolTipText(
            Statistics.ConfidenceInterval.defaultConfinceTooltip
            + ". Also, you may chose " + Statistics.ConfidenceInterval.NONE.name()
            + " to disable the computation of confidence intervals.");
      //</editor-fold>

      //<editor-fold defaultstate="collapsed" desc="tryAdd radios, group them, preseection etc...">
      ButtonGroup radGrp = new ButtonGroup();

      for (Statistics.ConfidenceInterval nxt_confLev : confidenceLevels) {
         JRadioButton radio = new JRadioButton(nxt_confLev.getConfidencePercentile());
         radGrp.add(radio);

         radio.setToolTipText(nxt_confLev.toString());
         confidenceRadiosPanel.add(radio);
         if (nxt_confLev == Statistics.ConfidenceInterval.Percentile_95) {
            radio.setSelected(true);
         } else {
            radio.setSelected(false);
         }
      }
      //</editor-fold>

      //<editor-fold defaultstate="collapsed" desc="show the options dialog">
      int confDialog = JOptionPane.showOptionDialog(
            null, msgPanel, "Level of confidence",
            JOptionPane.OK_CANCEL_OPTION, JOptionPane.QUESTION_MESSAGE, null, null, null);

      if (confDialog == JOptionPane.CANCEL_OPTION) {
         userAbortedMsg();
      }
      //</editor-fold>

      //<editor-fold defaultstate="collapsed" desc="find  the selected radio and infer and return the enum chosen">
      Enumeration<AbstractButton> elements = radGrp.getElements();
      while (elements.hasMoreElements()) {
         JRadioButton jRadButton = (JRadioButton) elements.nextElement();
         if (jRadButton.isSelected()) {
            return Statistics.ConfidenceInterval.find(jRadButton.getText());
         }
      }//while
      //</editor-fold>

      throw new UnsupportedOperationException("No choice from user.. sth is wrong here..");
   }

   public static JFileChooser selectFiles(String dirPath, boolean exitOnAbort, String title, String tooltip) {
      int optionReturned = 0;

      JFileChooser jchosser = new JFileChooser(dirPath);

      jchosser.setMultiSelectionEnabled(true);
      jchosser.setFileSelectionMode(jchosser.FILES_AND_DIRECTORIES);

      jchosser.setToolTipText(tooltip);
      jchosser.setDialogTitle(title);
      jchosser.setApproveButtonText("Select");
      jchosser.setApproveButtonMnemonic('S');
      jchosser.setMultiSelectionEnabled(true);
      jchosser.addChoosableFileFilter(new FileFilter() {
         @Override
         public boolean accept(File file) {
            return file.getName().endsWith(".csv");
         }

         @Override
         public String getDescription() {
            return "Accepts only csv (comma separated) files";
         }
      });

      do {
         optionReturned = jchosser.showDialog(null, "Select");
      } while (optionReturned != JFileChooser.CANCEL_OPTION && optionReturned != JFileChooser.APPROVE_OPTION);

      if (optionReturned == JFileChooser.CANCEL_OPTION) {
         userAbortedMsg();
         if (exitOnAbort) {
            System.exit(1);
         }
         return null;
      }

      return jchosser;
   }

   /**
    * Groups the ResultFile instances from the parameter array, to SetupsGrp instances
    * based on common scenario parameter setting (parameter name and value), based on
    * parameters excluding the ones to be ignored.
    *
    * @param resultsFiles
    * @param paramsIgnrd Ignores these parameter names while grouping.
    *
    * @return a set of grouped ResultsFile instance
    */
   public static Set<SetupsGrp> groupRFs(ResultsFile[] resultsFiles, Set<String> paramsIgnrd) {

      Set<SetupsGrp> groups = new HashSet<>();
      /*
       * - take the head of the list or stop looping if the list is empty
       * - loop over the list of all results files, 
       * - find the ones that are equal to the head of the list
       * - exclude them from beeing searched again
       */
      List<ResultsFile> resList = new ArrayList<>();
      resList.addAll(Arrays.asList(resultsFiles));

      ResultsFile head = null;

      while (!resList.isEmpty()) {
         if (null == (head = resList.remove(0))) {
            continue; // ignore problematic files passed as null references
         }

         SetupsGrp nxtGrp = new SetupsGrp(head, paramsIgnrd);
         groups.add(nxtGrp);

         for (Iterator<ResultsFile> it = resList.iterator(); it.hasNext();) {
            ResultsFile nxt_ResFile = it.next();
            if (nxtGrp.tryAdd(nxt_ResFile)) {
               it.remove(); /* if found its group.. no need to recheck in next while loop
                * Otherwise it is left in the list and thus it will be rechecked in a next 
                * loop.*/

            }
         }//for
      }//while

      return groups;
   }

   public static void logInfo(String logMsg, Object[] msgArr) {
      Logger.getGlobal().log(Level.INFO, logMsg, msgArr);
   }
}
