package sim;

import app.SimulatorApp;
import app.properties.IProperty;
import app.properties.Preprocessor;
import app.properties.Registry;
import app.properties.Simulation;
import app.properties.Space;
import app.properties.valid.Values;
import static app.properties.valid.Values.CLOSEST_IN_RANGE;
import static app.properties.valid.Values.MAX_CACHED_EPC_STD;
import static app.properties.valid.Values.OUT_OF_RANGE;
import static app.properties.valid.Values.RANDOM_IN_RANGE;
import caching.CachingPoliciesFactory;
import caching.base.AbstractCachingPolicy;
import exceptions.CriticalFailureException;
import exceptions.InconsistencyException;
import exceptions.InvalidOrUnsupportedException;
import exceptions.ScenarioSetupException;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.io.PrintStream;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.NoSuchElementException;
import java.util.Objects;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.StringTokenizer;
import java.util.TreeSet;
import java.util.logging.Level;
import java.util.logging.Logger;
import sim.space.Area;
import sim.space.Point;
import sim.space.cell.CellRegistry;
import sim.space.cell.MacroCell;
import sim.space.cell.smallcell.SmallCell;
import sim.space.users.mobile.MUBuilder;
import sim.space.users.mobile.MUGroupsRegistry;
import sim.space.users.mobile.MobileGroup;
import sim.space.users.mobile.MobileUser;
import sim.time.AbstractClock;
import util.CommonFunctions;
import util.Couple;
import util.random.RandomGeneratorWrapper;

/**
 *
 * @author xvas
 */
public class Scenario {

    public static final Scenario NONE = new Scenario(-1, -1, -1);


    /*
    * The following maps contain the name of property as a key and its value.
    * There can be different types of values, therefore there is on map for each 
    * type of value(s).
     */
    /**
     * Map of properties with string values. Key: the name of the property;
     * value: the string value of the property.
     */
    private final Map<String, String> strProps;
    private final Map<String, String> customProps;
    /**
     * Map of properties with a list of string values. Key: the name of the
     * property; value: the list of string values of the property.
     */
    private final Map<String, List< String>> strListProps;
    /**
     * Map of properties with integer values. Key: the name of the property;
     * value: the integer value of the property.
     */
    private final Map<String, Integer> intProps;
    /**
     * Map of properties with a list of integer values. Key: the name of the
     * property; value: the list of integer values of the property.
     */
    private final Map<String, List< Integer>> intListProps;
    /**
     * Map of properties with double values. Key: the name of the property;
     * value: the double value of the property.
     */
    private final Map<String, Double> doubleProps;
    /**
     * Map of properties with a list of double values. Key: the name of the
     * property; value: the list of double values of the property.
     */
    private final Map<String, List<Double>> doubleListProps;
    private final int level;
    /**
     * transition probabilities as defined for the current scenario
     */
    private List<double[][]> transProbabilities;
    /**
     * A list of property name and value couples that keeps track of all the
     * different property values in a single setup used to create different
     * scenarios running in parallel.
     */
    private final SortedSet<Couple<String, String>> _replicationProperties;

    {// initilization block shared by all constructors
        customProps = new HashMap<>();
        strProps = new HashMap<>();
        strListProps = new HashMap<>();
        intProps = new HashMap<>();
        intListProps = new HashMap<>();
        doubleProps = new HashMap<>();
        doubleListProps = new HashMap<>();
        replicationCount = 0;
    }
    /**
     * Number of known replicate of this scenario. Each simTime a replica of
     * this scenario is created, this counter is incremented.
     */
    private int replicationCount;
    private final String setupID;
    private static int idGen = 0;
    private RandomGeneratorWrapper randGen;

    /**
     * Constructor for zero level scenarios, i.e. scenarios that do not stem
     * from replicating an other scenario.
     *
     * @see replicate()
     */
    protected Scenario() {
        this._replicationProperties = new TreeSet<>(new Comparator<Couple>() {

            @Override
            public int compare(Couple t1, Couple t2) {
                return t1.compareToFirst(t2);
            }
        });
        replicationCount = 0;
        setupID = String.valueOf(++idGen);
        level = 0;
    }

    private Scenario(int mokeRpl, int mokeID, int mokeLvl) {
        this._replicationProperties = new TreeSet<>(new Comparator<Couple>() {

            @Override
            public int compare(Couple t1, Couple t2) {
                return t1.compareToFirst(t2);
            }
        });
        replicationCount = mokeRpl;
        setupID = String.valueOf(mokeID);
        level = mokeLvl;
    }

    protected Scenario(int replicationLevel) throws ScenarioSetupException {
        this._replicationProperties = new TreeSet<Couple<String, String>>(new Comparator<Couple>() {

            @Override
            public int compare(Couple t1, Couple t2) {
                return t1.compareToFirst(t2);
            }
        });
        replicationCount = 0;
        setupID = String.valueOf(++idGen);
        level = replicationLevel;
        if (replicationLevel == 0) {
            throw new ScenarioSetupException("Illegal use of constructor. Use only default "
                    + "constructor  Scenario() with no arguments for zero level scenarios.");
        }
    }

    /**
     * @return a replica with replication level of this scenario plus one.
     */
    protected Scenario replica() throws ScenarioSetupException {
        int repLevel = this.level + 1;
        Scenario _replica = new Scenario(++this.replicationCount);

        /* Hope the following is more efficient than invoking
       * simSetup_shallowCopyDataStructures(original);*/
        _replica.strProps.putAll(this.strProps);
        _replica.customProps.putAll(this.customProps);
        _replica.strListProps.putAll(this.strListProps);

        _replica.doubleProps.putAll(this.doubleProps);
        _replica.doubleListProps.putAll(this.doubleListProps);

        _replica.intProps.putAll(this.intProps);
        _replica.intListProps.putAll(this.intListProps);

        _replica._replicationProperties.addAll(_replicationProperties);

        return _replica;
    }

    private RuntimeException onPropertyFail(String propertyName, String typeSearched) {
        ScenariosFactory.checkInitStatus();

        StringBuilder msg = new StringBuilder(180);
        msg.append("No such ").append(typeSearched).append(" property loaded with name \"");
        msg.append(propertyName).append("\"");
        String loadedType = Registry.getTypeOf(propertyName);
        if (loadedType != null) {
            msg.append("; the property has ").append(loadedType).append(" type");
        }

        //  msg.append("\n\n").append(this.toString());
        return new RuntimeException(msg.toString());
    }

    /**
     * @return the setPropertyupID
     */
    public String getSetupID() {
        return setupID;
    }

    /**
     * The setPropertyup family number. A setPropertyup family number is a
     * unique id number computed after the property values of this scenario,
     * excluding the repeat number. Therefore, repeats of the same setPropertyup
     * have the same setPropertyupFamily number.
     *
     * @return the unique number of this setPropertyup's family.
     */
    public int setupSignatureHash() {
        int hash = 5;
        hash = 7 * hash + this.strProps.hashCode();
        hash = 17 * hash + this.customProps.hashCode();
        hash = 21 * hash + this.strListProps.hashCode();

        //<editor-fold defaultstate="collapsed" desc="exclude repeat number (i.e. the seed) from hash computation">
        Iterator<Map.Entry<String, Integer>> iterator = this.intProps.entrySet().iterator();
        while (iterator.hasNext()) {
            Map.Entry<String, Integer> next = iterator.next();
            hash = 23 * hash + next.getValue().hashCode();
        }
        //</editor-fold>

        hash = 3 * hash + this.intListProps.hashCode();

        hash = 17 * hash + this.doubleProps.hashCode();
        hash = 25 * hash + this.doubleListProps.hashCode();
        return hash;
    }

    /**
     * The hash code is computed after all the property values.
     *
     * @return
     */
    @Override
    public int hashCode() {
        int hash = 5;
        hash = 7 * hash + this.strProps.hashCode();
        hash = 17 * hash + this.customProps.hashCode();
        hash = 21 * hash + this.strListProps.hashCode();
        hash = 23 * hash + this.intProps.hashCode();
        hash = 3 * hash + this.intListProps.hashCode();
        hash = 17 * hash + this.doubleProps.hashCode();
        hash = 25 * hash + this.doubleListProps.hashCode();
        return hash;
    }

    /**
     * Two scenarios are equal if all properties have the same values (including
     * the repeat number.
     *
     * @param other
     * @return
     */
    @Override
    public boolean equals(Object other) {
        if (other == null) {
            return false;
        }
        if (getClass() != other.getClass()) {
            return false;
        }
        final Scenario otherScenario = (Scenario) other;
        if (!Objects.equals(this.strProps, otherScenario.strProps)) {
            return false;
        }
        if (!Objects.equals(this.customProps, otherScenario.customProps)) {
            return false;
        }
        if (!Objects.equals(this.strListProps, otherScenario.strListProps)) {
            return false;
        }
        if (!Objects.equals(this.intProps, otherScenario.intProps)) {
            return false;
        }
        if (!Objects.equals(this.intListProps, otherScenario.intListProps)) {
            return false;
        }
        if (!Objects.equals(this.doubleProps, otherScenario.doubleProps)) {
            return false;
        }
        if (!Objects.equals(this.doubleListProps, otherScenario.doubleListProps)) {
            return false;
        }
        return true;
    }

    @Override
    public String toString() {
        StringBuilder _toString = new StringBuilder();
        _toString.append("#Printing scenario setup with setup id: ").append(
                setupID).append("\n");
        _toString.append("#Properties loaded from file: ").append(
                Preprocessor.defaultPreprocessor().getPath()).append("\n");

        //<editor-fold defaultstate="collapsed" desc="int - int list">
        _toString.append("\n#int properties:\n");
        for (Map.Entry<String, Integer> entry : this.intProps.entrySet()) {
            String propName = entry.getKey();
            Integer propValue = entry.getValue();
            _toString.append("\t").append(propName).append("=").append(propValue).append("\n");
        }

        _toString.append("\n#int list properties:\n");
        for (Map.Entry<String, List<Integer>> entry : this.intListProps.entrySet()) {
            String propName = entry.getKey();
            List<Integer> propValue = entry.getValue();
            _toString.append("\t");
            _toString.append(propName + "=");
            for (Iterator<Integer> it = propValue.iterator(); it.hasNext();) {
                int nxtval = it.next();
                _toString.append(nxtval).append(", ");
            }
            _toString.append("\n");

        }
//</editor-fold>

        //<editor-fold defaultstate="collapsed" desc="double - double list">
        _toString.append("\n#double properties:\n");
        for (Map.Entry<String, Double> entry : this.doubleProps.entrySet()) {
            String propName = entry.getKey();
            Double propValue = entry.getValue();
            _toString.append("\t").append(propName).append("=").append(propValue).append("\n");
        }

        _toString.append("\n#double list properties:\n");
        for (Map.Entry<String, List<Double>> entry : this.doubleListProps.entrySet()) {
            String propName = entry.getKey();
            List<Double> propValue = entry.getValue();
            _toString.append("\t");
            _toString.append(propName + "=");
            for (Iterator<Double> it = propValue.iterator(); it.hasNext();) {
                double nxtval = it.next();
                _toString.append(nxtval).append(", ");
            }
            _toString.append("\n");
        }
//</editor-fold>

        //<editor-fold defaultstate="collapsed" desc="String - String list">
        _toString.append("\n#String properties:\n");
        for (Map.Entry<String, String> entry : this.strProps.entrySet()) {
            String propName = entry.getKey();
            String propValue = entry.getValue();
            _toString.append("\t").append(propName).append("=").append(propValue).append("\n");
        }

        _toString.append("\n#Custom properties:\n");
        for (Map.Entry<String, String> entry : this.customProps.entrySet()) {
            String propName = entry.getKey();
            String propValue = entry.getValue();
            _toString.append("\t").append(propName).append("=").append(propValue).append("\n");
        }

        _toString.append("\n#String list properties:\n");
        for (Map.Entry<String, List<String>> entry : this.strListProps.entrySet()) {
            String propName = entry.getKey();
            List<String> propValue = entry.getValue();
            _toString.append("\t");
            _toString.append(propName).append("=");
            Iterator<String> iter_values = propValue.iterator();
            while (iter_values.hasNext()) {
                String nxtval = iter_values.next();
                _toString.append(nxtval).append(", ");
            }
            _toString.append("\n");
        }
//</editor-fold>

        return _toString.toString();
    }

    public void print(PrintStream out) {
        out.print(toString());
    }

    /**
     * Makes as many replicate as the number of values in the parameter, each
     * with one property value added from the list.
     *
     * @param valuesList
     * @param propertyName
     * @return
     * @throws exceptions.ScenarioSetupException
     * @throws exceptions.InvalidOrUnsupportedException
     */
    public List<Scenario> replicate(List<String> valuesList, String propertyName)
            throws ScenarioSetupException, InvalidOrUnsupportedException {
        List<Scenario> reps = new ArrayList<>(valuesList.size());
        for (String nxt_value : valuesList) {
            Scenario replica = this.replica();
            replica.setProperty(propertyName, nxt_value.trim());
            replica.addReplicationProperty(propertyName, nxt_value.trim());
            reps.add(replica);
        }
        return reps;
    }

    //<editor-fold defaultstate="collapsed" desc=" = = = = = = methods for handling property values = = = = = = = ">
    public void addReplicationProperty(String propName, String val) {
        _replicationProperties.add(new Couple<>(propName, val));
    }

    /**
     * @return the properties that yield multiple scenarios due to having
     * multiple values in the same properties setup file, coupled by their
     * values in the current scenario.
     */
    public SortedSet<Couple<String, String>> getReplicationProperties() {
        return Collections.unmodifiableSortedSet(_replicationProperties);
    }

    public void setProperty(String propName, String val) throws InvalidOrUnsupportedException, ScenarioSetupException {
        try {
            String type = Registry.getTypeOf(propName);
            if (type == null) {
                throw new InvalidOrUnsupportedException(
                        "Type not known for property: \"" + propName
                        + "\" Please specify type of property @property.types.ini."
                );
            }

            StringTokenizer toks;

            if (type.equals(Registry.Type.CUSTOM.toString())) {
                customProps.put(propName, val);
            } else if (type.equals(Registry.Type.INT.toString())) {
                intProps.put(propName, (int) Double.parseDouble(val));

            } else if (type.equals(Registry.Type.LIST_INT.toString())) {
                toks = new StringTokenizer(val, Values.LIST_SEPARATOR);
                List<Integer> intlist = new ArrayList<>();
                while (toks.hasMoreElements()) {
                    String tokTrimed = toks.nextToken().trim();
                    if (tokTrimed.equals(Values.NONE)
                            || tokTrimed.equals(Values.UNDEFINED)) {
                        continue;
                    }
                    intlist.add((int) Double.parseDouble(tokTrimed));
                }
                intListProps.put(propName, intlist);

            } else if (type.equals(Registry.Type.DOUBLE.toString())) {
                doubleProps.put(propName, Double.valueOf(val));

            } else if (type.equals(Registry.Type.LIST_DOUBLE.toString())) {
                toks = new StringTokenizer(val, Values.LIST_SEPARATOR);
                List<Double> dbllist = new ArrayList<>();
                while (toks.hasMoreElements()) {
                    dbllist.add(Double.parseDouble(toks.nextToken().trim()));
                }
                doubleListProps.put(propName, dbllist);

            } else if (type.equals(Registry.Type.STRING.toString())) {
                strProps.put(propName, relativePathCheck(val));

            } else if (type.equals(Registry.Type.CUSTOM.toString())) {
                customProps.put(propName, relativePathCheck(val));

            } else if (type.equals(Registry.Type.LIST_STRING.toString())) {
                toks = new StringTokenizer(val, Values.LIST_SEPARATOR);
                List strlist = new ArrayList<>();
                while (toks.hasMoreElements()) {
                    String value = toks.nextToken().trim();
                    strlist.add(relativePathCheck(value));
                }
                strListProps.put(propName, strlist);

            }
        } catch (IOException ex) {
            throw new InvalidOrUnsupportedException(ex);
        } catch (java.lang.NumberFormatException nf) {
            throw new exceptions.ScenarioSetupException("For property: \"" + propName + "\" with value \"" + val + "\"", nf);
        }
    }

    /**
     * If relativeChecked is a relative path string, then the relative part is
     * replaced by the parent directly path of the properties file as the latter
     * is defined in the main method's arguments in class SimulatorApp.
     *
     * @param str
     * @return
     * @throws java.io.IOException if the path does not exist or any other IO
     * problem happens.
     */
    public String relativePathCheck(String str) throws IOException {
        String relativeChecked = str;
        if (relativeChecked.startsWith("./")
                || relativeChecked.startsWith(".\\")) {
            relativeChecked = (new File(SimulatorApp.getMainArgs().getPropertiesParent() + "/" + relativeChecked)).getCanonicalPath();
        } else if (relativeChecked.startsWith("./")
                || relativeChecked.startsWith(".\\")) {
            relativeChecked = (new File(SimulatorApp.getMainArgs().getPropertiesParent() + "/" + relativeChecked.substring(1))).getCanonicalPath();
        }
        return relativeChecked;
    }

    public int intProperty(IProperty property) {
        return intProperty(property.propertyName());
    }

    public int intProperty(String propertyName) {
        Integer toreturn = intProps.get(propertyName);
//        if (toreturn == null) {
//            throw onPropertyFail(propertyName, Registry.Type.INT.toString());
//        }
        return toreturn;
    }

    public List<Integer> listOfIntegersProperty(IProperty property) {
        return listOfIntProperty(property.propertyName());
    }

    public List<Integer> listOfIntProperty(String propertyName) {
        List<Integer> toreturn = intListProps.get(propertyName);
//        if (toreturn == null) {
//            throw onPropertyFail(propertyName, Registry.Type.LIST_INT.toString());
//        }
        return toreturn;
    }

    public double doubleProperty(IProperty property) {
        return doubleProperty(property.propertyName());
    }

    public double doubleProperty(String propertyName) {
        Double toreturn = doubleProps.get(propertyName);
//        if (toreturn == null) {
//            throw onPropertyFail(propertyName, Registry.Type.DOUBLE.toString());
//        }
        return toreturn;
    }

    public List<Double> listOfDoublesProperty(IProperty property) {
        return listOfDoublesProperty(property.propertyName());
    }

    public List<Double> listOfDoublesProperty(String propertyName) {
        List<Double> toreturn = doubleListProps.get(propertyName);
//        if (toreturn == null) {
//            throw onPropertyFail(propertyName, Registry.Type.LIST_DOUBLE.toString());
//        }
        return toreturn;
    }

    public String stringProperty(IProperty property) {
        return stringProperty(property.propertyName());
    }

    public String stringProperty(String propertyName) {
        String toreturn = strProps.get(propertyName);
//        if (toreturn == null) {
//            throw onPropertyFail(propertyName, Registry.Type.STRING.toString());
//        }
        return toreturn;
    }

    public List<String> listOfStringsProperty(IProperty property) {
        return listOfStringsProperty(property.propertyName());
    }

    public List<String> listOfStringsProperty(String propertyName) {
        List<String> toreturn = strListProps.get(propertyName);
//        if (toreturn == null) {
//            throw onPropertyFail(propertyName, Registry.Type.LIST_STRING.toString());
//        }
        return toreturn;
    }

    /**
     * @param property must have string type.
     * @return
     * @throws InvalidOrUnsupportedException
     */
    public boolean isFalse(String property) throws InvalidOrUnsupportedException {
        return !isTrue(property);
    }

    public boolean isFalse(IProperty property) throws InvalidOrUnsupportedException {
        return isFalse(property.propertyName());
    }

    /**
     * @param property must have string type.
     *
     * @return
     * @throws InvalidOrUnsupportedException
     */
    public boolean isTrue(String property) throws InvalidOrUnsupportedException {
        String value = stringProperty(property);
        if (value.equalsIgnoreCase(Values.TRUE)) {
            return true;
        } else if (value.equalsIgnoreCase(Values.FALSE)) {
            return false;
        } else {
            throw new InvalidOrUnsupportedException("The value of property " + property
                    + " is not valid for boolean check: " + value);
        }
    }

    public boolean isTrue(IProperty propertyName) throws InvalidOrUnsupportedException {
        return isTrue(propertyName.propertyName());
    }
    //</editor-fold>

    ////// custom properties /////
    public int seed() {
        String propertyName = Simulation.SEED.propertyName();
        String str = customProps.get(propertyName);

        if (str == null || str.equalsIgnoreCase("TIME")) {
            return (int) (Math.random() * System.currentTimeMillis() / 1000000);
        } else {
            return Integer.parseInt(str);
        }
    }

    /**
     * Parses the mobile transition probabilities for each group of MUs.
     *
     * The probabilities are parsed only the first time this method is invoked.
     * For consequent calls, the already parsed probabilities are returned.
     *
     *
     *
     ***************************** Different groups of mobiles
     * ***************************
     *
     *
     * Each element in the list is an array of doubles that defines the mobility
     * probabilities of each different group of mobiles. In other words, the
     * different elements in the list, i.e. the different double [][] arrays in
     * the list, correspond to the different probabilities between the different
     * groups. The different groups are separated by a "|" in the parsed
     * property string value. *
     *
     *
     *
     ************ Different subset of mobiles within groups of mobiles
     * *****************
     *
     *
     * Different rows within the same element (double [][] array) correspond to
     * the different probabilities of each subset of MUs within the same group
     * of MUs.
     *
     * Within each subset's probabilities, the first double is the percentage of
     * MUs that conform to the following nine probability values, each for each
     * moving direction. For instance, the first 10 double values are i) the
     * percentage of MUs that conform to ii) the following 9 transition
     * probabilities, then the next 10 doubles refer to the following subset of
     * MUs within the same group etc.
     *
     *
     *
     * @return a list of mobile transition probabilities per group of mobiles.
     *
     * @throws InvalidOrUnsupportedException In case there is something wrong
     * with the parsed percentages of probabilities
     */
    public List<double[][]> parseMobileTransProbs() throws InvalidOrUnsupportedException {
        if (transProbabilities != null) { // in this case it is already loaded; just return it
            return Collections.unmodifiableList(transProbabilities);
        }

        transProbabilities = new ArrayList<>();
        String propertyName = Space.MU__TRANSITION_PROBABILITIES__MATRIX.propertyName();
        String probs_str = customProps.get(propertyName).trim();

        // find the probs sets for each group of mobiles
        StringTokenizer tok = new StringTokenizer(probs_str, "|");
        while (tok.hasMoreElements()) {// for the next group of mobiles. 
            String nxtProbSet_str = tok.nextToken();
            String exceptionMsg = "During parsing subset of mobile probabilities: "
                    + "\n \""
                    + nxtProbSet_str
                    + "\""
                    + "\nThere must be a \"$\" followed by 10 "
                    + "double numbers for each subset of MUs. The double numbers denote are "
                    + " i) the percentage of mobiles that "
                    + "conform to ii) 9 mobile transition probabilities. ";

            StringTokenizer tokProbs = new StringTokenizer(nxtProbSet_str, ",");
            if (tokProbs.countTokens() % 10 != 0) {
                throw new InvalidOrUnsupportedException(
                        exceptionMsg + "\nThe number of parsed tokens in property "
                        + Space.MU__TRANSITION_PROBABILITIES__MATRIX.name()
                        + " is " + tokProbs.countTokens()
                        + ": \"" + nxtProbSet_str + "\""
                );
            }

            //<editor-fold defaultstate="collapsed" desc="read 9 probabilities">
            double[][] subsetProbs = new double[tokProbs.countTokens() / 10][10];
            /* Each row refers to a subset of MUs, 
          * including the percentage of MUs at 
          * column zero, followed by the 9 probabilities 
          * of the transition matix
             */

            int count = 0;
            double checkSum_probs = 0;
            double checkSum_subsetPercect = 0;

            while (tokProbs.hasMoreElements()) {
                int row = count / 10;
                int column = count % 10;

                if (column == 0) { // start with the % of mus in the form of "$x%"
                    String musPercent_str = tokProbs.nextToken().trim();

                    if (!musPercent_str.startsWith("$")) {
                        throw new InvalidOrUnsupportedException(
                                "Missing \"$\" before "
                                + "\"" + musPercent_str + "\" "
                                + " in the beggining of mobile's set probabilities "
                                + ": \"" + nxtProbSet_str + "\""
                                + "\n"
                                + exceptionMsg);

                    }

                    subsetProbs[row][column] = Double.parseDouble(
                            musPercent_str.substring(1)// get rid of "$"
                    );

                    checkSum_probs = 0; // restart checking if probs are getting equal to 1
                    checkSum_subsetPercect += subsetProbs[row][column];
                } else {// summarize probs from columns 1 to 9
                    subsetProbs[row][column] = Double.parseDouble(tokProbs.nextToken());

                    checkSum_probs += subsetProbs[row][column];
                    if (column == 9 && checkSum_probs > 1.01) {
                        throw new InconsistencyException("Transition matrix does not summarize to 1.0 " //confusing with groups if printed: for subset " + (row + 1)
                                + " that refers to percentage of MUs " + subsetProbs[row][0] + ". "
                                + " The sum of probabiliies is " + checkSum_probs);
                    }
                }

                count++;
            }//while

            if (checkSum_subsetPercect < 1.0 || checkSum_subsetPercect > 1.01) {
                throw new InconsistencyException("The percentages of MUs subsets summarizes to " + checkSum_subsetPercect + " instead of 1.0.");
            }
            //</editor-fold>

            transProbabilities.add(subsetProbs);
        }

        for (double[][] transProbability : transProbabilities) {
            System.err.println("****\n");

            for (int i = 0; i < transProbability.length; i++) {
                double[] transProbability1 = transProbability[i];
                System.err.println(CommonFunctions.toString(transProbability1));
            }
        }

        return Collections.unmodifiableList(transProbabilities);
    }
    ////// custom properties /////

    //<editor-fold defaultstate="collapsed" desc=" = = = = = = methods for initializing simulation members = = = = = = = ">
    /**
     * Initializes MUs.
     *
     * It initializes MUs to the point indicated by their group, and then
     * connects MUs to the cell which is i) covering their initial position and
     * ii) complies with the property-defined connection policy.
     *
     * @param simulation
     * @param groupsRegistry
     * @param area
     * @param registry
     * @param cachingPolicies
     * @return
     * @throws CriticalFailureException
     */
    public List<MobileUser> initConnMUsAtGrpPos(
            sim.Simulation simulation, MUGroupsRegistry groupsRegistry,
            Area area, CellRegistry registry,
            Iterable<AbstractCachingPolicy> cachingPolicies
    ) throws CriticalFailureException {

        // fill this up with mus from all registeredGroups and return it at the end of the method
        List<MobileUser> toReturnLst = new ArrayList<>(groupsRegistry.getTotalNumOfMUs());

        String mobTransDecisions;
        int itemSize;
        int itemRndIDRange;
        double percentage;

        List<String> conn2SCPolicy;

        conn2SCPolicy = this.parseConnPolicySC();
        mobTransDecisions = this.stringProperty(Space.MU__TRANSITION_DECISIONS);
        itemSize = this.intProperty(Space.ITEM__SIZE);
        itemRndIDRange = this.intProperty(Space.ITEM__RND_ID_RANGE);
        percentage = this.doubleProperty(Simulation.PROGRESS_UPDATE);

        //<editor-fold defaultstate="collapsed" desc="for each group of MUs {">
        // note that registeredGroups are sorted after their id.
        SortedMap<Integer, MobileGroup> groupsMap = groupsRegistry.registeredGroups();
        Iterator<Integer> groupID_iter = groupsMap.keySet().iterator();
        while (groupID_iter.hasNext()) {

            MobileGroup nxtGroup = groupsMap.get(groupID_iter.next());
            int mus_num = nxtGroup.getSize();

            //</editor-fold>
            //<editor-fold defaultstate="collapsed" desc="report/log progress">
            Logger.getLogger(Scenario.class.getCanonicalName() + " for setup id = " + setupID)
                    .log(Level.INFO, "Initializing MUs on the area:\n\t{0}/{1}", new Object[]{0, mus_num});
            int count = 0;
            int sum = (int) -percentage * 100;
            int printPer = (int) (mus_num * percentage);
            printPer = printPer == 0 ? 1 : printPer; // otherwise causes arithmetic exception devide by zero in some cases
            //</editor-fold>

            for (int i = 1; i <= mus_num; i++) {

                int nxtMuID = groupsRegistry.generateMobileID(nxtGroup.getId(), i);

                double[] probs = nxtGroup.transProbsForMember(i);

                //<editor-fold defaultstate="collapsed" desc="nxtMUBuilder">
                Point startPoint = area.getPoint(nxtGroup.getInitPos());

//                if (nxtMuID == 1) {//xxx
//                    startPoint = new Point(70, 70);
//                }

                MUBuilder nxtMUBuilder = new MUBuilder(
                        simulation, nxtGroup, startPoint, probs,
                        conn2SCPolicy, cachingPolicies
                );

                nxtMUBuilder.id(nxtMuID);

                nxtMUBuilder.area(area);

                nxtMUBuilder.transitionDecisions(mobTransDecisions);

                int tmp;
                if (itemRndIDRange > 1) {
                    tmp = (int) (getRandomGenerator().randIntInRange(1, itemRndIDRange));
                } else {
                    tmp = nxtMuID;
                }

                MobileUser mu = nxtMUBuilder.build();
                //</editor-fold>
                toReturnLst.add(mu);

                //<editor-fold defaultstate="collapsed" desc="report/log progress">
                if (++count % printPer == 0) {
                    sum += percentage * 100;
                    Logger.getLogger(Scenario.class.getCanonicalName() + " for setup id = " + setupID)
                            .log(Level.INFO, "\tdone:{0}%", sum);
                }
                //</editor-fold> 
            }//for every MU in group
        }

        return toReturnLst;

    }

    private Set<SmallCell> initSCsRnd(sim.Simulation simulation,
            Area area, Iterable<AbstractCachingPolicy> cachingMethods) throws CriticalFailureException {
        try {
            Set<SmallCell> _init_SmallCells_random = new HashSet<>();
            int scs_num = intProperty(Space.SC__NUM);
            //<editor-fold defaultstate="collapsed" desc="logging">
            int count = 0;
            double percentage = simulation.getScenario().doubleProperty(Simulation.PROGRESS_UPDATE);

            int sum = 0;
            int printPer = (int) (scs_num * percentage);
            printPer = printPer == 0 ? 1 : printPer; // otherwise causes arithmetic exception devide by zero in some cases
            Logger.getLogger(Scenario.class.getCanonicalName() + " for setup id = " + setupID)
                    .log(Level.INFO, "Initializing small cells on the area:\n\t{0}/{1}", new Object[]{0, scs_num});
//</editor-fold>
            for (int i = 0; i < scs_num; i++) {
                Point randCenter = area.getRandPoint();
                SmallCell nxt_sc = new SmallCell(simulation, randCenter, area, cachingMethods);
                //<editor-fold defaultstate="collapsed" desc="logging">
                if (++count % printPer == 0) {
                    sum += (int) (10000.0 * printPer / scs_num) / 100;// roiunding, then percent
                    Logger.getLogger(Scenario.class.getCanonicalName() + " for setup id = " + setupID)
                            .log(Level.INFO, "\t{0}%", sum);
                }
                _init_SmallCells_random.add(nxt_sc);
//</editor-fold>
            }
            return _init_SmallCells_random;
        } catch (Exception ex) {
            throw new CriticalFailureException(ex);
        }
    }

    private Set<SmallCell> initSCs(
            sim.Simulation sim, Area area, Iterable<AbstractCachingPolicy> cachingMethods,
            Point... center) throws CriticalFailureException {
        try {
            Set<SmallCell> _init_SmallCells_random = new HashSet<>();
            int scs_num = intProperty(Space.SC__NUM);
            if (scs_num != center.length) {
                throw new InconsistencyException(
                        "Number of SCs in parameter " + Space.SC__NUM.name() + "= " + scs_num
                        + " does not match the number of SC centers=" + center.length
                );
            }
            //<editor-fold defaultstate="collapsed" desc="logging">
            int count = 0;
            double percentage = sim.getScenario().doubleProperty(Simulation.PROGRESS_UPDATE);

            int sum = 0;
            int printPer = (int) (scs_num * percentage);
            printPer = printPer == 0 ? 1 : printPer; // otherwise causes arithmetic exception devide by zero in some cases
            Logger.getLogger(Scenario.class.getCanonicalName() + " for setup id = " + setupID)
                    .log(Level.INFO, "Initializing small cells on the area:\n\t{0}/{1}", new Object[]{0, scs_num});
            //</editor-fold>
            for (int i = 0; i < scs_num; i++) {
                Point nxtCenter = center[i];
                SmallCell nxtSC = new SmallCell(sim, nxtCenter, area, cachingMethods);
                //<editor-fold defaultstate="collapsed" desc="log user update">
                boolean logUsrUpdt = ++count % printPer == 0;
                if (logUsrUpdt) {
                    sum += (int) (10000.0 * printPer / scs_num) / 100;// roiunding, then percent
                    Logger.getLogger(Scenario.class.getCanonicalName() + " for setup id = " + setupID)
                            .log(Level.INFO, "\t{0}%", sum);
                }
                _init_SmallCells_random.add(nxtSC);
                //</editor-fold>
            }
            return _init_SmallCells_random;
        } catch (Exception ex) {
            throw new CriticalFailureException(ex);
        }
    }

    /**
     * Each line in the trace must be in the following, comma separated textual
     * format, modeling the next small cell to be created: integer coordinate x;
     * integer coordinate y; double radius; double maximum data transmission
     * rate; boolean compute area coverage based on radius length; double
     * backhaul data rate\n
     *
     * @param sim
     * @param area
     * @return
     * @throws CriticalFailureException
     */
    private Set<SmallCell> initSCsTrace(sim.Simulation sim,
            Area area, Iterable<AbstractCachingPolicy> cachingMethods) throws CriticalFailureException {

        int countLines = 0;
        String nxt_sc_line = "";
        try {
            String tracePath = stringProperty(Space.SC__TRACE_PATH);
            Logger.getLogger(Scenario.class.getCanonicalName() + " for setup id = " + setupID).
                    log(Level.INFO, "Initializing small cells on the area from trace: {0}",
                            new Object[]{tracePath}
                    );

            Set<SmallCell> initFromTrace = new HashSet<>();

            File traceF = (new File(tracePath)).getCanonicalFile();
            //<editor-fold defaultstate="collapsed" desc="checking traceF">
            if (!traceF.exists()) {
                throw new FileNotFoundException("Path to trace file for initializing small "
                        + "cells on the area does not exist: " + traceF.getCanonicalPath());
            }
            if (!traceF.canRead()) {
                throw new CriticalFailureException("Cannot read from path to trace file for "
                        + "initializing small cells on the area: " + traceF.getCanonicalPath());
            }
            //</editor-fold>
            //<editor-fold defaultstate="collapsed" desc="about logging progress update">
            long traceSize = traceF.length(); // rough estimation
            long byteConsumed = 0; // howmany bytes consumed from trace file.          
            //</editor-fold>

            BufferedReader traceR = new BufferedReader(new FileReader(traceF));

            while (null != (nxt_sc_line = traceR.readLine())) {
                countLines++;

                if (nxt_sc_line.startsWith("#") || nxt_sc_line.isEmpty()) {
                    continue; // ignore comments
                }

                String nxtSC_descr;
                //<editor-fold defaultstate="collapsed" desc="get rid of comments in line">
                StringTokenizer commnetTok = new StringTokenizer(nxt_sc_line, "#");
                if (commnetTok.hasMoreTokens()) {
                    nxtSC_descr = commnetTok.nextToken(); // the first token is the one we want
                } else {
                    nxtSC_descr = nxt_sc_line;
                }
                //</editor-fold>
                StringTokenizer tokens = new StringTokenizer(nxtSC_descr, ";");

                Point center = null;
                double radius = 0;
                String neighbors;

                int id = Integer.parseInt(tokens.nextToken().trim());

                int x = Integer.parseInt(tokens.nextToken().trim());
                int y = Integer.parseInt(tokens.nextToken().trim());
                center = new Point(x, y);

                radius = Double.parseDouble(tokens.nextToken().trim());
                if (radius == -1) {
                    radius
                            = sim.getRandomGenerator().getGaussian(
                                    sim.getScenario().doubleProperty(Space.SC__RADIUS__MEAN),
                                    sim.getScenario().doubleProperty(Space.SC__RADIUS__STDEV)
                            );
                }

                neighbors = tokens.nextToken().trim();
                Map<Integer, Double> cellID_probs = null;
                if (!(neighbors.equals(Values.UNDEFINED)
                        || neighbors.equals(Values.NULL)
                        || neighbors.equals(Values.NONE)
                        || neighbors.equals(""))) {
                    cellID_probs = initSCsTraceTokenizeNeighbs(neighbors);
                }

                long capacity = util.CommonFunctions.parseSizeToBytes(
                        stringProperty(Space.SC__BUFFER__SIZE));

                SmallCell nxt_sc = new SmallCell(
                        id, sim, center, radius,
                        area, cellID_probs, cachingMethods, capacity
                );

                initFromTrace.add(nxt_sc);

                //<editor-fold defaultstate="collapsed" desc="logging progress">
                byteConsumed += nxt_sc_line.length() * 2; //16 bit chars
                int progress = (int) (10000.0 * byteConsumed / traceSize) / 100;// rounding, then percent
                Logger.getLogger(Scenario.class.getCanonicalName() + " for setup id = " + setupID).log(Level.INFO, "\t{0}%", progress);
                Logger.getLogger(Scenario.class.getCanonicalName() + " for setup id = " + setupID).log(Level.FINE, "\tSmall Cell created: {0}", nxt_sc.toSynopsisString());
                //</editor-fold>
            }

            Logger.getLogger(Scenario.class.getCanonicalName() + " for setup id = " + setupID).log(Level.INFO, "Finished. Total small cells created: {0}", initFromTrace.size());
            return initFromTrace;
        } catch (InvalidOrUnsupportedException | CriticalFailureException | IOException | NumberFormatException | NoSuchElementException ex) {
            String msg = "";
            if (ex.getClass() == NumberFormatException.class
                    || ex.getClass() == NoSuchElementException.class) {
                msg = "Trace file is mulformed at line "
                        + countLines
                        + ":\n\t"
                        + nxt_sc_line;
            }
            throw new CriticalFailureException(msg, ex);
        }
    }

    /**
     * Initializes Cells. Cells are added to the area by the constructor of
     * SmallCell.
     *
     * @param sim
     * @param area
     * @param cachingPolicies
     * @return
     * @throws exceptions.CriticalFailureException
     */
    public Set<SmallCell> initSCs(sim.Simulation sim, Area area,
            Iterable<AbstractCachingPolicy> cachingPolicies) throws CriticalFailureException {
        Set<SmallCell> scSet = null;
        try {
            List<String> scsInit = listOfStringsProperty(Space.SC__INIT);
            if (scsInit.isEmpty()) {
                Logger.getLogger(Scenario.class.getCanonicalName() + " for setup id = " + setupID)
                        .log(Level.WARNING, "There are no small cells defined in property {0}", Space.SC__INIT.name());
            }
            if (scsInit.size() == 1) {

                switch (scsInit.get(0).toLowerCase()) {

                    case Values.RANDOM:
                        scSet = initSCsRnd(sim, area, cachingPolicies);
                        break;

                    case Values.TRACE:
                        scSet = initSCsTrace(sim, area, cachingPolicies);
                        break;

                    default:
                        Point center = area.getPoint(scsInit.get(0));
                        scSet = initSCs(sim, area, cachingPolicies, center);
                        break;

                }

            } else {

                Point[] centers = area.getPoints(scsInit);
                scSet = initSCs(sim, area, cachingPolicies, centers);

            }

            //<editor-fold defaultstate="collapsed" desc="discover neighbors sanity check">
            if (sim.getCachingPolicies().contains(Values.CACHING__NAIVE__TYPE03)
                    && sim.getScenario().intProperty(Space.SC__WARMUP_PERIOD) < 100) {
                throw new CriticalFailureException(Values.CACHING__NAIVE__TYPE03 + " is enabled. Finding neighbors for each SC is mandatory."
                        + " But the time interval for discovering neighbors is too small: "
                        + sim.getScenario().intProperty(Space.SC__WARMUP_PERIOD));
            }
            //</editor-fold>

            return scSet;
        } catch (CriticalFailureException | UnsupportedOperationException ex) {
            throw new CriticalFailureException(ex);
        }

    }

    /**
     * Initializes mobile users on the area based on the setPropertyup. This
     * means that it adds them to the area and connects them to cells.
     *
     * @param simulation
     * @param groupsRegistry
     * @param area
     * @param registry
     * @return
     * @throws fmtsnc.exceptions.CriticalFailureException
     */
    List<MobileUser> initConnMUs(
            sim.Simulation simulation, MUGroupsRegistry groupsRegistry, Area area,
            CellRegistry registry, Iterable<AbstractCachingPolicy> cachingPolicies) throws CriticalFailureException {

        List<MobileUser> musLst;

        musLst = initConnMUsAtGrpPos(simulation, groupsRegistry, area,
                registry, cachingPolicies);

        //<editor-fold defaultstate="collapsed" desc="shuffle mus iff property ..">
        String muShuffling = this.stringProperty(Space.MU__SHUFFLE);
        switch (muShuffling) {
            case Values.NEVER:
                break; // do not shufle

            case Values.UPON_CREATION:
            case Values.ALWAYS:
                Collections.shuffle(musLst, getRandomGenerator().getMersenneTwister());
                break;
            default:
                throw new UnsupportedOperationException("Value " + muShuffling + " is currently not supported for "
                        + " property " + Space.MU__SHUFFLE);
        }
        //</editor-fold>
        return musLst;

    }

    public MacroCell initMC(sim.Simulation simulation, Area area) throws CriticalFailureException {
        try {
            MacroCell macro = MacroCell.createMacrocell(simulation, area);
            return macro;
        } catch (Exception ex) {
            Logger.getLogger(Scenario.class.getCanonicalName() + " for setup id = " + setupID)
                    .log(Level.SEVERE, ex.getMessage(), ex);
            throw new CriticalFailureException(ex);
        }
    }

    public RandomGeneratorWrapper getRandomGenerator() {
        if (randGen == null) {
            try {
                randGen = new RandomGeneratorWrapper(seed());
            } catch (RuntimeException ex) {
                throw new InconsistencyException("seed property not defined or not retrieved from"
                        + " properties file. Make sure the properties file is loaded *and*"
                        + " parsed before using any method that invokes the random generator",
                        ex);
            }
        }
        return randGen;
    }

    CellRegistry initSCRegistry(sim.Simulation simulation, MUGroupsRegistry groupsRegistry,
            Set<SmallCell> scs, MacroCell mc, Area area) throws CriticalFailureException {
        try {
            CellRegistry reg = new CellRegistry(simulation, groupsRegistry, scs, mc, area);
            Logger.getLogger(Scenario.class.getCanonicalName() + " for setup id = " + setupID)
                    .log(Level.INFO, "Cell registry initialized.\n");
            return reg;
        } catch (InvalidOrUnsupportedException ex) {
            Logger.getLogger(Scenario.class.getCanonicalName() + " for setup id = " + setupID)
                    .log(Level.SEVERE, ex.getMessage(), ex);
            throw new CriticalFailureException(ex);
        }
    }

    Area initArea(sim.Simulation sim) throws CriticalFailureException {
        Area theArea = new Area(sim,
                intProperty(Space.AREA__Y),
                intProperty(Space.AREA__X));
        Logger.getLogger(Scenario.class.getCanonicalName() + " for setup id = " + setupID)
                .log(Level.INFO, "{0}: {1}x{2} area; number of points={3}\n",
                        new Object[]{
                            sim.simTime(),
                            intProperty(Space.AREA__Y),
                            intProperty(Space.AREA__X),
                            theArea.size()
                        });
        return theArea;
    }

    AbstractClock initClock(sim.Simulation sim) throws CriticalFailureException {
        AbstractClock clock = null;
        try {
            String clock_classpath = stringProperty(Simulation.Clock.TYPE);

            Constructor constructor = Class.forName(clock_classpath).getConstructor(
                    new Class[]{sim.Simulation.class});
            Object clockInstance = constructor.newInstance(sim);
            if (!(clockInstance instanceof sim.time.AbstractClock)) {
                throw new InconsistencyException("Not a valid clock class. Must be an extention of "
                        + sim.time.AbstractClock.class.getCanonicalName());
            }

            return clock = (AbstractClock) clockInstance;
        } catch (Exception ex) {
            Logger.getLogger(Scenario.class.getCanonicalName() + " for setup id = " + setupID)
                    .log(Level.SEVERE, ex.getMessage(), ex);
            throw new CriticalFailureException(ex);
        }
    }

    private Map<Integer, Double> initSCsTraceTokenizeNeighbs(String neighbors) {
        StringTokenizer tokens = new StringTokenizer(neighbors, ",");
        Map<Integer, Double> _init_SmallCells__trace__tokenizeNeighs = new HashMap<>(tokens.countTokens() / 2);

        while (tokens.hasMoreElements()) {
            int id = Integer.parseInt(tokens.nextToken());
            double prob = Double.parseDouble(tokens.nextToken());

            _init_SmallCells__trace__tokenizeNeighs.put(id, prob);
        }

        return _init_SmallCells__trace__tokenizeNeighs;
    }

    //</editor-fold>
    /**
     * Parses the list of connection policy rules to a SC.
     *
     * The list is parsed the first simTime this method is invoked or it is
     * simply returned for consequent calls to this method.
     *
     * @return the list of connection policy rules
     * @throws InvalidOrUnsupportedException
     */
    public List<String> parseConnPolicySC() {

        List<String> conn2SCPolicy = listOfStringsProperty(Space.SC__CONNECTION_POLICY);

        if (conn2SCPolicy.size() == 1) {
            if (conn2SCPolicy.get(0).equals(app.properties.valid.Values.CC)
                    || conn2SCPolicy.get(0).equals(app.properties.valid.Values.CACHED_CONTENT)) {
                conn2SCPolicy.remove(0);
                conn2SCPolicy.add(OUT_OF_RANGE);
                conn2SCPolicy.add(MAX_CACHED_EPC_STD);
                conn2SCPolicy.add(RANDOM_IN_RANGE);
            }
        }
        if (conn2SCPolicy.size() == 1) {
            if (conn2SCPolicy.get(0).equals(app.properties.valid.Values.CR)
                    || conn2SCPolicy.get(0).equals(app.properties.valid.Values.CLOSEST__RANGE)) {
                conn2SCPolicy.remove(0);
                conn2SCPolicy.add(CLOSEST_IN_RANGE);
                //conn2SCPolicy.add(MAX_CACHED_EPC_STD);
                conn2SCPolicy.add(RANDOM_IN_RANGE);
            }
        }
        return conn2SCPolicy;
    }

    List<AbstractCachingPolicy> loadCachingPolicies() throws CriticalFailureException {
        List<AbstractCachingPolicy> loaded = new ArrayList();

        Iterable<String> cachingPolicies = listOfStringsProperty(app.properties.Caching.CACHING_POLICIES
        );

        for (String nxtMthd : cachingPolicies) {
            try {
                loaded.add(CachingPoliciesFactory.addCachingPolicy(nxtMthd));
            } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException | NoSuchMethodException ex) {
                throw new CriticalFailureException(ex);
            }
        }
        return loaded;
    }

}// inner class Scenario
