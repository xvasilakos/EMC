package sim.space.users;

import caching.MaxPop;
import caching.base.AbstractCachingPolicy;
import caching.incremental.Oracle;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import sim.run.SimulationBaseRunner;
import sim.content.Chunk;
import sim.content.request.DocumentRequest;
import sim.space.Point;
import sim.space.cell.MacroCell;
import sim.space.cell.smallcell.SmallCell;
import utilities.Couple;

/**
 *
 * @author xvas
 */
public class StationaryUser extends CachingUser {

    public StationaryUser(int id, SimulationBaseRunner sim,
            Iterable<AbstractCachingPolicy> cachingPolicies) {

        super(id, sim, cachingPolicies);
    }

    public StationaryUser(int id, SimulationBaseRunner sim, int connectedSinceSC,
            SmallCell connectionSC, MacroCell connectionMC,
            Iterable<AbstractCachingPolicy> cachingPolicies) {

        super(id, sim, connectedSinceSC, connectionSC, connectionMC,
                cachingPolicies);
    }

    public void cancelAndDeregisterPCOrders() {
        super.cancelAndDeregisterPCOrders(getCurrentlyConnectedSC());
    }

    /**
     * This is a stationary user. Thus, the default getCoordinates are the
     * getCoordinates of the center of the connection cell.
     *
     * @return the getCoordinates of the center of the connection cell
     */
    @Override
    public Point getCoordinates() {
        return getCurrentlyConnectedSC().getCenter();
    }

    @Override
    public void addAllRequests(Collection<DocumentRequest> requests) throws Throwable {
        for (DocumentRequest r : requests) {
            addRequest(r);
        }
    }
    
    @Override
    public void addRequest(DocumentRequest r) throws Throwable {
        super.addRequest(r);

        double residenceTimeAvg = _currentlyConnectedSC.getSmoothedResidenceDuration();

        cacheDescisionsPerformRegisterPC(residenceTimeAvg, r);

        r.cacheForOracle(_currentlyConnectedSC,
                new Couple(residenceTimeAvg, 0.0),
                getSim().getRateSCWlessInChunks()/*in stationary users, 
                        each request get the whole bandwidth to emulate one request per user*/
        );

    }

    private void cacheDescisionsPerformRegisterPC(double timeWindow, DocumentRequest r) throws Throwable {
        setLastSCForCacheDecisions(_currentlyConnectedSC);

//////////////////////// rates are split per each user's request
        float slice = 1.0F; // use 1, not getRequests().size() because one stationary emulates multiple users
        long bhRateInChunks = Math.round(getSim().getRateBHInChunks() * timeWindow / slice);

// update popularity info for requests
        _currentlyConnectedSC.getPopInfo().registerPopInfo(r);

        for (AbstractCachingPolicy policy : getCachingPolicies()) {
            if (policy instanceof MaxPop
                    || policy instanceof Oracle) {
                // cached object stay permanently in cache.
                continue;
            }

            long budgetInChunks = bhRateInChunks;// this is how much you can fetch from the backhaul and request to cache
            List<Chunk> requestToCache = new ArrayList();

            List<Chunk> unconsumedLst = r.getUnconsumedChunksInSequence(policy);
            for (Iterator<Chunk> it = unconsumedLst.iterator(); it.hasNext() && budgetInChunks-- > 0;) {
                Chunk nxtChunk = it.next();
                _currentlyConnectedSC.getDmdPC(policy).registerUpdtInfoPC(nxtChunk, this, 1.0);
                requestToCache.add(nxtChunk);
            }

//// 1. start with  cache missed
//                List<Chunk> missed = mostRecentlyCacheMissesPerPolicy.get(policy);
//                for (Iterator<Chunk> it = missed.iterator(); it.hasNext() && budgetInChunks-- > 0;) {
//                    Chunk nxtChunk = it.next();
//                    _currentlyConnectedSC.getDmdPC(policy).registerUpdtInfoPC(nxtChunk, this);
//                    requestToCache.add(nxtChunk);
//                }
//
//// 2. continue with the ones fetch through the BH (backhaul)
//                List<Chunk> bh = mostRecentlyConsumedBH.get(policy);
//                for (Iterator<Chunk> it = bh.iterator(); it.hasNext() && budgetInChunks-- > 0;) {
//                    Chunk nxtChunk = it.next();
//                    _currentlyConnectedSC.getDmdPC(policy).registerUpdtInfoPC(nxtChunk, this);
//                    requestToCache.add(nxtChunk);
//                }
//
//// 3. finally, the ones downloaded from the MC - it is not likely that budgetInChunks > 0 by now.. 
//                List<Chunk> mc = mostRecentlyConsumedMC.get(policy);
//                for (Iterator<Chunk> it = mc.iterator(); it.hasNext() && budgetInChunks-- > 0;) {
//                    Chunk nxtChunk = it.next();
//                    _currentlyConnectedSC.getDmdPC(policy).registerUpdtInfoPC(nxtChunk, this);
//                    requestToCache.add(nxtChunk);
//                }

// Now cache the ones decided above that fit the budghet of the backhaul 
            _currentlyConnectedSC.cacheDecisions(
                    policy, this, _currentlyConnectedSC, requestToCache
            );

        }

    }

    public void forceCompleteRequests() {
        for (DocumentRequest r : getRequests()) {
            r.forceComplete(simTime());
        }
    }
}
