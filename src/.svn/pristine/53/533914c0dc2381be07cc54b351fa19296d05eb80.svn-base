package sim.space.cell;

import app.properties.Space;
import app.properties.valid.Values;
import exceptions.InvalidOrUnsupportedException;
import java.io.FileNotFoundException;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.PriorityQueue;
import java.util.Set;
import java.util.TreeMap;
import sim.ISimulationMember;
import utils.ISynopsisString;
import sim.run.SimulationBaseRunner;
import sim.space.Area;
import sim.space.Point;
import sim.space.cell.smallcell.SmallCell;
import sim.space.users.UserGroup;
import sim.space.users.mobile.MobileGroup;
import sim.space.users.mobile.MobileGroupsRegistry;
import sim.space.users.mobile.MobileUser;
import utils.CommonFunctions;
import utilities.Couple;

/**
 * A registry of macro cell and small cells
 *
 * @author Xenofon Vasilakos xvas@aueb.gr
 */
public class CellRegistry implements ISimulationMember, ISynopsisString {

    private final SimulationBaseRunner _simulation;
    /**
     * key: ID of SC
     *
     * Value: SmallCell with the given ID
     */
    private final Map<Integer, SmallCell> _cells;
    private final MacroCell _macroCell;
    /**
     * Number of Handoffs from a source smaller, mapped to a key that depends on
     * probabilities policy.
     *
     * Uses a string key which depends on the handoff probabilities computation
     * policy. If the key is the id of a small cell only, then probabilities
     * depend only on the location of MUs before they handoff. Alternatively, if
     * the key depends on both the MUs' group and their cell, then probabilities
     * are computed per location and group.
     */
    private final Map<String, Double> _handoffsOutgoing = new HashMap<>();
    private final Map<String, Double> _handoffsIncoming = new HashMap<>();
    private final Map<Couple<String, String>, Double> _handoffsBetween = new HashMap<>();
    /**
     * Handover duration from a coming cell (couple.first is the disconnection
     * cell) to a destination cell (couple.second is the connection cell)
     */
    private final Map<Couple<String, String>, Double> interCellHandoverDuration = new HashMap<>();
    /**
     * The last thirty samples used for computing the stdev
     */
    private final Map<Couple<String, String>, Couple<double[], Integer>> interCellHandoverDurationLastSamples = new HashMap<>();
    private static final int SAMPLES_SIZE = 30;
    /**
     * Residence duration when coming from another cell (couple.first is the
     * former cell and couple.second is the residence cell)
     */
    private final Map<Couple<String, String>, Double> interCellResidenceDuration = new HashMap<>();
    private final Map<Couple<String, String>, Couple<double[], Integer>> interCellResidenceDurationLastSamples = new HashMap<>();
    private final String _mobilityModel;
    private final MobileGroupsRegistry _muGroupRegistry;
    private final double _probJitter;

    public CellRegistry(
            SimulationBaseRunner sim, MobileGroupsRegistry groupRegistry, Set<SmallCell> smallCells,
            MacroCell mc, Area area) throws InvalidOrUnsupportedException {

        this._simulation = sim;

        _mobilityModel = sim.getScenario().stringProperty(Space.MOBILITY_MODEL, false);
        _probJitter = sim.getScenario().doubleProperty(Space.SC__HANDOFF_PROBABILITY__STDEV);

        this._muGroupRegistry = groupRegistry;

        this._cells = new TreeMap<>();
        Iterator<SmallCell> cellsIter = smallCells.iterator();
        while (cellsIter.hasNext()) {
            SmallCell sc = cellsIter.next();
            int scID = sc.getID();
            this._cells.put(scID, sc);
        }

        this._macroCell = mc;

    }

    @Override
    public String toString() {
        return this._simulation.toString() + " "
                + this._muGroupRegistry.toString() + " "
                + "; Cells: <" + CommonFunctions.toString(_cells)
                + ">; macrocell: " + _macroCell.toString()
                + "; mobility model: " + _mobilityModel
                + "; probability jitter: " + _probJitter;
    }

    public String toSynopsisString() {
        return this._simulation.toString() + " "
                + this._muGroupRegistry.toSynopsisString() + " "
                + "; Cells: <" + CommonFunctions.toString(_cells)
                + ">";
    }

    public void printProbsToCurrentPath() {
        try (PrintStream printer = new PrintStream("./probs.txt")) {
            Set<Couple<String, String>> betweenCellsKeySet = _handoffsBetween.keySet();
            Iterator<Couple<String, String>> betweenCells_it = betweenCellsKeySet.iterator();
            while (betweenCells_it.hasNext()) {
                Couple<String, String> couple = betweenCells_it.next();
                printer.println("src: " + couple.getFirst());
                printer.println("dest: " + couple.getSecond());
            }
        } catch (FileNotFoundException ex) {
            throw new RuntimeException(ex);
        }
    }

    /**
     * @return the cellRegistry
     */
    public Collection<SmallCell> cellsRegistered() {
        return Collections.unmodifiableCollection(_cells.values());
    }

    /**
     * @return the macroCell
     */
    public MacroCell getMacroCell() {
        return _macroCell;
    }

    /**
     * @return a randomly chosen small cell from the registry
     */
    public SmallCell rndSC() {
        Collection<SmallCell> scs = cellsRegistered();

        int size = scs.size();
        int rnd = _simulation.getRandomGenerator().randIntInRange(0, size - 1);
        int i = 0;
        for (SmallCell cell : scs) {
            if (i == rnd) {
                return cell;
            }
            i++;
        }

        throw new RuntimeException("Wrong random number generated.");
    }

    /**
     * @param mu
     * @return the small cell covering the current position of mu that is closer
     * to the mu, or null if the mu is out of coverage of any small cell.
     */
    public PriorityQueue<SmallCell> closestCoveringSCs(MobileUser mu) {
        Point muPoint = mu.getCoordinates();
        return muPoint.getClosestCoveringSCs(false, true);
    }

    public SmallCell coveringRandomSmallcell(MobileUser mu) throws InvalidOrUnsupportedException {
        Point muPoint = mu.getCoordinates();
        List<SmallCell> coveringSmallerCells = new ArrayList(muPoint.getCoveringSCs());
        if (coveringSmallerCells.isEmpty()) {
            return null;
        }

        int lastPos = coveringSmallerCells.size() - 1;
        int rndPos = _simulation.getRandomGenerator().randIntInRange(0, lastPos);
        return coveringSmallerCells.get(rndPos);
    }

    @Override
    public final int simID() {
        return _simulation.getID();
    }

    @Override
    public final SimulationBaseRunner getSim() {
        return _simulation;
    }

    @Override
    public final int simTime() {
        return _simulation.simTime();
    }

    @Override
    public String simTimeStr() {
        return "[" + simTime() + "]";
    }

    @Override
    public CellRegistry simCellRegistry() {
        return this;
    }

    /**
     * Update how much time has a mobile stayed connected to nextSC given that
     * it was handed over to nextSC from prevSC.
     *
     * @param grp
     * @param comingFrom
     * @param residenceSC
     * @param newDuration
     */
    public void updtResidenceTime(UserGroup grp, SmallCell comingFrom,
            SmallCell residenceSC, int newDuration) {

        if (comingFrom == null) {
            return; // can happen at startup
        }

        String comingFromID, residenceID;
        switch (_mobilityModel) {
            case Values.LOCATION:
                comingFromID = comingFrom.getID() + "";
                residenceID = residenceSC.getID() + "";
                break;

            case Values.LOCATION__PLUS__GROUP:
                comingFromID = CommonFunctions.combineCellMUGroup(comingFrom, grp == null ? - 1 : grp.getId());
                residenceID = CommonFunctions.combineCellMUGroup(residenceSC, grp == null ? - 1 : grp.getId());
                break;

            default:
                throw new UnsupportedOperationException("Unknonwn or unsupported policy " + _mobilityModel
                        + " set for parameter " + Space.MOBILITY_MODEL.propertyName());
        }//switch

        Double historyDuration = interCellResidenceDuration.get(new Couple(comingFromID, residenceID));
        Couple theCells = new Couple(comingFromID, residenceID);

        double newWeight = residenceSC.getConnectedMUs().isEmpty() ? 0.3 : 1.0 / (residenceSC.getConnectedMUs().size());
        if (historyDuration == null) {
            historyDuration = getSim().getScenario().doubleProperty(Space.SC__INIT_DURATION__RESIDENCE);

            double samples[] = new double[SAMPLES_SIZE];
            interCellResidenceDurationLastSamples.put(theCells, new Couple(samples, 0));
        } else {
            // cyclic update of last #SAMPLES_SIZE samples
            Couple<double[], Integer> samples2Idx = interCellResidenceDurationLastSamples.get(theCells);
            int idx = (1 + samples2Idx.getSecond()) % SAMPLES_SIZE;
            samples2Idx.getFirst()[idx] = newDuration;
            samples2Idx.setSecond(idx);
        }

        residenceSC.updtSmoothedResidenceDuration(newDuration, newWeight);

        double val = newWeight * newDuration + (1 - newWeight) * historyDuration;

        interCellResidenceDuration.put(theCells, val);
    }

    public void updtHandoverTransitionTime(MobileUser mu, SmallCell disconFrom, SmallCell conTo, int newDuration) {

        UserGroup grp = mu.getUserGroup();

        if (disconFrom == null) {
            return; // can happen at startup
        }

        String disconFromID, conToID;
        switch (_mobilityModel) {
            case Values.LOCATION:
                disconFromID = disconFrom.getID() + "";
                conToID = conTo.getID() + "";
                break;

            case Values.LOCATION__PLUS__GROUP:
                disconFromID = CommonFunctions.combineCellMUGroup(disconFrom, grp == null ? - 1 : grp.getId());
                conToID = CommonFunctions.combineCellMUGroup(conTo, grp == null ? - 1 : grp.getId());
                break;

            default:
                throw new UnsupportedOperationException("Unknonwn or unsupported policy " + _mobilityModel
                        + " set for parameter " + Space.MOBILITY_MODEL.propertyName());
        }//switch

        Couple theCells = new Couple(disconFromID, conToID);
        Double historyDuration = interCellHandoverDuration.get(theCells);
        if (historyDuration == null) {
            historyDuration = getSim().getScenario().doubleProperty(Space.SC__INIT_DURATION__HANDOVER);

            double samples[] = new double[SAMPLES_SIZE];
            interCellHandoverDurationLastSamples.put(theCells, new Couple(samples, 0));
        } else {
            // cyclic update of last #SAMPLES_SIZE samples
            Couple<double[], Integer> samples2Idx = interCellHandoverDurationLastSamples.get(theCells);
            int idx = (1 + samples2Idx.getSecond()) % SAMPLES_SIZE;
            samples2Idx.getFirst()[idx] = newDuration;
            samples2Idx.setSecond(idx);
        }

        double newWeight = 0.3;

        conTo.updtAvgHandoverDuration(newDuration, newWeight);

        double val = newWeight * newDuration + (1 - newWeight) * historyDuration;

        interCellHandoverDuration.put(theCells, val);
    }

    /**
     * Updates the history of handoff probabilities between handoff source and
     * handoff destination SCs.
     *
     * @param mu
     * @param src
     * @param dest
     */
    public void updtHandoffProbs(MobileUser mu, SmallCell src, SmallCell dest) {

        UserGroup grp = mu.getUserGroup();

        String srcID, destID;
        // increase transtion-counting maps //
        switch (_mobilityModel) {
            case Values.LOCATION:
                srcID = src.getID() + "";
                destID = dest.getID() + "";
                break;

            case Values.LOCATION__PLUS__GROUP:
                srcID = CommonFunctions.combineCellMUGroup(src, grp == null ? - 1 : grp.getId());
                destID = CommonFunctions.combineCellMUGroup(dest, grp == null ? - 1 : grp.getId());
                break;

            default:
                throw new UnsupportedOperationException("Unknonwn or unsupported policy " + _mobilityModel
                        + " set for parameter " + Space.MOBILITY_MODEL.propertyName());
        }//switch
        Couple couple = new Couple(srcID, destID);
        Double outgoing = _handoffsOutgoing.get(srcID);
        Double incoming = _handoffsIncoming.get(destID);
        Double between = _handoffsBetween.get(couple);
        _handoffsOutgoing.put(srcID, outgoing == null ? 1 : outgoing + 1);
        _handoffsIncoming.put(destID, incoming == null ? 1 : incoming + 1);
        _handoffsBetween.put(couple, between == null ? 1 : between + 1);
    }

    /**
     * @param grp
     * @param src
     * @param dest
     * @return the handoffs__total__Src_toDestCell
     */
    public double getHandoffsBetweenCells(UserGroup grp, SmallCell src, SmallCell dest) {

        String srcID, destID;
        // increase transtion-counting maps //
        switch (_mobilityModel) {

            case Values.LOCATION:
                srcID = src.getID() + "";
                destID = dest.getID() + "";
                break;

            case Values.LOCATION__PLUS__GROUP:
                srcID = CommonFunctions.combineCellMUGroup(src, grp == null ? - 1 : grp.getId());
                destID = CommonFunctions.combineCellMUGroup(dest, grp == null ? - 1 : grp.getId());
                break;

            default:
                throw new UnsupportedOperationException("Unknonwn or unsupported policy " + _mobilityModel
                        + " for parameter " + Space.MOBILITY_MODEL.propertyName());
        }//switch
        Double num = _handoffsBetween.get(new Couple(srcID, destID));
        if (num == null) {
            return 0;
        }
        return num;
    }

    public Couple<Double, Double> getResidenceDurationBetween(UserGroup grp, SmallCell fromSC, SmallCell residentSC, boolean use95percentile) {
        String comingFromSCID, residentSCID;
        // increase transtion-counting maps //
        switch (_mobilityModel) {

            case Values.LOCATION:
                comingFromSCID = fromSC.getID() + "";
                residentSCID = residentSC.getID() + "";
                break;

            case Values.LOCATION__PLUS__GROUP:
                comingFromSCID = CommonFunctions.combineCellMUGroup(fromSC, grp == null ? - 1 : grp.getId());
                residentSCID = CommonFunctions.combineCellMUGroup(residentSC, grp == null ? - 1 : grp.getId());
                break;

            default:
                throw new UnsupportedOperationException("Unknonwn or unsupported policy " + _mobilityModel
                        + " for parameter " + Space.MOBILITY_MODEL.propertyName());
        }//switch

        Couple theCells = new Couple(comingFromSCID, residentSCID);

        Double avg = interCellResidenceDuration.get(theCells);

        if (avg == null) {
            return new Couple(100.0, 0.0);
        }

        double percentile95 = 0;
        if (use95percentile) {
            // compute stdev first
            double s = 0;
            double[] samples = interCellResidenceDurationLastSamples.get(theCells).getFirst();
            for (double nxtSample : samples) {
                s += Math.pow(avg - nxtSample, 2);
            }
            s = Math.sqrt(s);

            percentile95 = 1.96 * s;
        }

        return new Couple(avg, percentile95);
    }

    public Couple<Double, Double> getHandoverDurationBetween(UserGroup grp, SmallCell disconSC, SmallCell conToSC, boolean use95percentile) {

        String disconSCID, connSCID;
        // increase transtion-counting maps //
        switch (_mobilityModel) {

            case Values.LOCATION:
                disconSCID = disconSC.getID() + "";
                connSCID = conToSC.getID() + "";
                break;

            case Values.LOCATION__PLUS__GROUP:
                disconSCID = CommonFunctions.combineCellMUGroup(disconSC, grp == null ? - 1 : grp.getId());
                connSCID = CommonFunctions.combineCellMUGroup(conToSC, grp == null ? - 1 : grp.getId());
                break;

            default:
                throw new UnsupportedOperationException("Unknonwn or unsupported policy " + _mobilityModel
                        + " for parameter " + Space.MOBILITY_MODEL.propertyName());
        }//switch
        
        Couple theCells = new Couple(disconSCID, connSCID);
        Double avg = interCellHandoverDuration.get(theCells);

        if (avg == null) {
            return new Couple(100.0, 0.0);
        }

        double percentile95 = 0;
        if (use95percentile) {
            // compute stdev first
            double s = 0;
            double[] samples = interCellHandoverDurationLastSamples.get(theCells).getFirst();
            for (double nxtSample : samples) {
                s += Math.pow(avg - nxtSample, 2);
            }
            s = Math.sqrt(s);

            percentile95 = 1.96 * s;
        }

        return new Couple(avg, percentile95);
    }

    public double getHandoffsOutgoing(UserGroup grp, SmallCell src) {

        String srcID;
        // increase transtion-counting maps //
        switch (_mobilityModel) {

            case Values.LOCATION:
                srcID = src.getID() + "";
                break;

            case Values.LOCATION__PLUS__GROUP:
                srcID = CommonFunctions.combineCellMUGroup(src, grp == null ? - 1 : grp.getId());
                break;

            default:
                throw new UnsupportedOperationException("Unknonwn or unsupported policy " + _mobilityModel
                        + " for parameter " + Space.MOBILITY_MODEL.propertyName());
        }//switch
        Double num = _handoffsOutgoing.get(srcID);
        if (num == null) {
            return 0;
        }
        return num;
    }

    public double getHandoffsIncoming(MobileUser mu, SmallCell dest) {

        UserGroup grp = mu.getUserGroup();
        String destID;
        // increase transtion-counting maps //
        switch (_mobilityModel) {

            case Values.LOCATION:
                destID = dest.getID() + "";
                break;

            case Values.LOCATION__PLUS__GROUP:
                destID = CommonFunctions.combineCellMUGroup(dest, grp == null ? - 1 : grp.getId());
                break;

            default:
                throw new UnsupportedOperationException("Unknonwn or unsupported policy " + _mobilityModel
                        + " for parameter " + Space.MOBILITY_MODEL.propertyName());
        }//switch
        Double num = _handoffsIncoming.get(destID);
        if (num == null) {
            return 0;
        }
        return num;
    }

    /**
     * @param grp
     * @param srcCell
     * @param destCell
     * @return the transition probability or -1 in case there is no transition
     * previously recorded or in case the source and destination cells coincide.
     * transition between the cells.
     */
    public double handoverProbability(MobileGroup grp, SmallCell srcCell, SmallCell destCell) {

        if (destCell.equals(srcCell)) {
            return 0;
        }

        double handoffsBetweenCells = getHandoffsBetweenCells(grp, srcCell, destCell);
        double outgoingHandoffs = getHandoffsOutgoing(grp, srcCell);

        if (handoffsBetweenCells == 0
                || outgoingHandoffs == 0) {
            return 0.0;
        }

        double prob = getSim().getRandomGenerator().getGaussian(1.0, _probJitter)
                /*robustness testing: intentional random error*/
                * handoffsBetweenCells / outgoingHandoffs;

        return Math.max(Math.min(1.0, prob), 0);// due to jittering
    }

    public SmallCell getCellCenteredAt(Point point) {
        for (SmallCell smallerCell : _cells.values()) {
            if (smallerCell.getCoordinates().getX() == point.getX()
                    && smallerCell.getCoordinates().getY() == point.getY()) {
                return smallerCell;
            }
        }
        return null;
    }

    /**
     * @param _ID
     * @return The SC for this ID or SmallCell.NONE if no cell does with that ID
     * exists (such as negative IDs).
     */
    public SmallCell scByID(Integer _ID) {
        if (_ID < 0) {
            return null;
        }

        return this._cells.get(_ID);

    }

 

    @Override
    /**
     * @return true iff same hashID.
     */
    public boolean equals(Object b) {
        if (b == null) {
            return false;
        }

        if (!(b instanceof CellRegistry)) {
            return false;
        }

        CellRegistry rg = (CellRegistry) b;
        return rg.getSim().equals(getSim());
    }

    @Override
    public int hashCode() {
        int hash = 7;
        hash = 61 * hash + Objects.hashCode(this._simulation);
        hash = 61 * hash + Objects.hashCode(this._cells);
        return hash;
    }

    /**
     * @return the mobilityModel
     */
    public String getMobilityModel() {
        return _mobilityModel;
    }

    public SmallCell getCellByID(Integer id) {
        return _cells.get(id);
    }

    public Map<Integer, Double> getTransitionNeighborsOf(SmallCell _currentlyConnectedSC) {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

}
