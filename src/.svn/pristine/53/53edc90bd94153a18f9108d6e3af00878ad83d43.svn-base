package sim.time;

import app.properties.Simulation;
import exceptions.NotIntiliazedException;
import java.awt.Toolkit;
import java.util.logging.Level;
import logging.LoggersRegistry;
import static logging.LoggersRegistry.CONSOLE_LOGGER;
import sim.ScenariosFactory;
import util.CommonFunctions;
import static sim.time.AbstractClock.realTime_str;
import static sim.time.AbstractClock.realTime_str;
import static sim.time.AbstractClock.realTime_str;
import static sim.time.AbstractClock.realTime_str;
import static sim.time.AbstractClock.realTime_str;
import static sim.time.AbstractClock.realTime_str;
import static sim.time.AbstractClock.realTime_str;
import static sim.time.AbstractClock.realTime_str;
import static sim.time.AbstractClock.realTime_str;
import static sim.time.AbstractClock.realTime_str;
import static sim.time.AbstractClock.realTime_str;
import static sim.time.AbstractClock.realTime_str;
import static sim.time.AbstractClock.realTime_str;
import static sim.time.AbstractClock.realTime_str;
import static sim.time.AbstractClock.realTime_str;
import static sim.time.AbstractClock.realTime_str;
import static sim.time.AbstractClock.realTime_str;
import static sim.time.AbstractClock.realTime_str;
import static sim.time.AbstractClock.realTime_str;
import static sim.time.AbstractClock.realTime_str;
import static sim.time.AbstractClock.realTime_str;
import static sim.time.AbstractClock.realTime_str;
import static sim.time.AbstractClock.realTime_str;
import static sim.time.AbstractClock.realTime_str;
import static sim.time.AbstractClock.realTime_str;
import static sim.time.AbstractClock.realTime_str;
import static sim.time.AbstractClock.realTime_str;
import static sim.time.AbstractClock.realTime_str;
import static sim.time.AbstractClock.realTime_str;
import static sim.time.AbstractClock.realTime_str;
import static sim.time.AbstractClock.realTime_str;
import static sim.time.AbstractClock.realTime_str;

/**
 * Clock used for simulations ending after a finite simulation time has passed.
 *
 * @author Xenofon Vasilakos xvas@aueb.gr
 */
public class FiniteTimeClock extends SimpleClock {

    protected final int maxTime;

    public FiniteTimeClock(sim.SimulationBase sim) {
        super(sim);
        if (sim == sim.NONE) {
            maxTime = -1;
            return;
        }

        maxTime = setup.intProperty(Simulation.Clock.MAX_TIME);

    }

    @Override
    protected void checkEnded(int time) throws NormalSimulationEndException {
        reportProgressLcl(time);
        super.checkEnded(time);

        if (time > maxTime) {
            try {
                Toolkit.getDefaultToolkit().beep();
            } catch (Exception e) {//ignore
            } finally {
                throw new NormalSimulationEndException("Simulation time expired.");
            }
        }
    }

    public int getMaxTime() {
        return maxTime;
    }

    private void reportProgressLcl(int time) {

        if (time % getSim().loggingSimTimePeriod() == 0) {
            try {

                String trcLogStr = "***********\n"
                        + (simulation.usesTraceOfRequests()
                                ? "\t- Loaded records from trace: {8} ({9}%)\n"
                                : "");

                CONSOLE_LOGGER.log(Level.INFO,
                        "***********\n"
                        + "Simulation {0} time {1}:\n"
                        + "\t- Local run time progress {2}%\n"
                        + "\t- Local time elapsed " + realTimeElapsedStr() + "\n"
                        + "\t- Simulation expected to finish in {3}\n"
                        /////////////
                        + trcLogStr
                        /////////////
                        + "***********\n"
                        + "Parallel Running simulations {4}\n"
                        + "\t- Global progress {5}%\n"
                        + "\t\t- Global simulations time elapsed {6}\n\n"
                        + "\t\t- Simulations batch expected to finish in {7}\n\n",
                        new Object[]{
                            /*0*//*0*/simID(),
                            /*1*/ simTime(),
                            /*2*/ progressPercent(),
                            /*3*/
                            realTime_str(
                                    (100.0 * realTimeElapsedL()
                                    / progressPercent() - realTimeElapsedL())),
                            /*4*/sim.SimulationBase.getRunningSimulations(),
                            /*5*/ globalProgressPercent(),
                            /*6*/ realGlobalTimeElapsedStr(),
                            /*7*/ globalTimeFinishExpectation(),
                            /*8*/ simulation.getWrkloadConsumed(),
                            /*9*/ simulation.getWrkloadConsumedPercent()
                        });
                CONSOLE_LOGGER.log(Level.INFO,
                        "Memory status in bytes:"
                        + "\n\t- total:{0}"
                        + "\n\t- max:\t{1}"
                        + "\n\t- free:\t{2}%",
                        new Object[]{
                            Runtime.getRuntime().totalMemory(),
                            Runtime.getRuntime().maxMemory(),
                            CommonFunctions.roundNumber(
                                    100.0 * Runtime.getRuntime().freeMemory() 
                                            / Runtime.getRuntime().maxMemory(), 2)
                        });
            } catch (NotIntiliazedException ex) {
                LoggersRegistry.CONSOLE_LOGGER.log(Level.SEVERE, null, ex);
            }
        }
    }

    public String globalTimeFinishExpectation() throws NotIntiliazedException {

        double globalProgressPercent = globalProgressPercent();
        if (globalProgressPercent == 0.0) {
            return "Unknown yet";
        }

        long expectation = (long) (100.0 * realGlobalTimeElapsedL() /
                globalProgressPercent - realGlobalTimeElapsedL());
        return realTime_str(expectation);
    }

    /**
     * Percentage of simulation simTime progress with two decimals
     *
     * @return
     */
    public double progressPercent() {
        return (int) (10000.0 * simTime() / maxTime) / 100.0;
    }

    /**
     * Percentage of simulations batch progress with two decimals.
     *
     * @return
     * @throws exceptions.NotIntiliazedException
     */
    public static double globalProgressPercent() throws NotIntiliazedException {
        double completedScenarios = (double) ScenariosFactory.completedScenariosNum() / ScenariosFactory.initialScenariosNum();
//        completedScenarios
//                = completedScenarios == 0
//                        ? (double) ScenariosFactory.consumedScenariosNum() / 2.0 / ScenariosFactory.initialScenariosNum()
//                        : completedScenarios;
        double globalProgressPercent = ((int) (10000 * completedScenarios)) / 100.0;
        return globalProgressPercent;
    }

    @Override
    public int tick() throws NormalSimulationEndException {
        return super.tick();
    }
}
