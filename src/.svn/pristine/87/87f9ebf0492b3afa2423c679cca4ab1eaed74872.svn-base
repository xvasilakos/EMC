package caching;

import caching.base.AbstractEPC;
import caching.base.AbstractCachingPolicy;
import caching.base.AbstractGainRplc_Priced;
import caching.base.AbstractPop;
import caching.base.AbstractPricing;
import caching.base.IPop;
import caching.incremental.EMC;
import caching.interfaces.rplc.ILRURplc;
import exceptions.CriticalFailureException;
import exceptions.InvalidOrUnsupportedException;
import exceptions.WrongOrImproperArgumentException;
import java.io.FileNotFoundException;
import java.io.IOException;
import java.io.PrintStream;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
import java.util.logging.Level;
import java.util.logging.Logger;
import sim.content.Chunk;
import sim.space.cell.demand_registry.PCDemand;
import static sim.space.cell.smallcell.BufferBase.BufferAllocationStatus.FailItemOverUtilizes;
import static sim.space.cell.smallcell.BufferBase.BufferAllocationStatus.ItemAlreadyCachedByOtherMUs;
import static sim.space.cell.smallcell.BufferBase.BufferAllocationStatus.ItemAlreadyCachedBySameMU;
import static sim.space.cell.smallcell.BufferBase.BufferAllocationStatus.Success;
import sim.space.cell.smallcell.ITimeBuffer;
import sim.space.cell.smallcell.PricedTimeBuffer;
import sim.space.cell.smallcell.SmallCell;
import sim.space.cell.smallcell.TimeBufferImpl;
import sim.space.users.CachingUser;
import sim.space.users.StationaryUser;
import sim.space.users.User;
import sim.space.users.mobile.MobileUser;
import util.Couple;

/**
 * A utility class with methods for:
 *
 * Canceling caching requests
 *
 *
 * @author Xenofon Vasilakos xvas@aueb.gr
 */
public abstract class Utils {

    public static final double SMOOTH_FACTOR_FOR_LEGACY_VALUE = 0.95;

    public static PrintStream printer;//yyy
//    public static PrintStream printer2;//yyy

    static {
        try {
            SimpleDateFormat sdfDate = new SimpleDateFormat("yyyy-MM-dd_HH-mm-ss");//dd/MM/yyyy
            Date now = new Date();
            String name = sdfDate.format(now) + ".txt";
            if (System.getProperty("os.name").equalsIgnoreCase("Linux")) {
                printer = new PrintStream("/home/xvas/Dropbox/2014-2015-EPC+POP/trunk/files/results/-1-" + name);
//                printer2 = new PrintStream("/home/xvas/Dropbox/2014-2015-EPC+POP/trunk/files/results/-2-" + name);
            } else {
                printer = new PrintStream("C:\\Users\\xvas\\Dropbox\\2014-2015-EPC+POP\\trunk\\files\\results\\-1-" + name);
//                printer = new PrintStream("C:\\Users\\xvas\\Dropbox\\2014-2015-EPC+POP\\trunk\\files\\results\\-2-" + name);
            }

        } catch (FileNotFoundException ex) {
            Logger.getLogger(AbstractGainRplc_Priced.class.getName()).log(Level.SEVERE, null, ex);
        }
    }
    private static final int monitorCell = -1;//  21;
    private static final AbstractCachingPolicy _policy = EMC.instance();//EPCPopNoRplc_c1.instance();

    public static void appendLogNewRecord(String txt, SmallCell sc, caching.base.AbstractCachingPolicy policy) {
        if ((sc.getID() == monitorCell || monitorCell == -1) && policy.getClass() == _policy.getClass()) {
            printer.append("\n\n[simTime=" + sc.simTime() + "]" + "\t" + txt);
        }
    }

    public static void trackUser(boolean newRec, String txt, User usr, boolean overrideMU) {
        if (usr.getID() % 100 == 0
                || overrideMU) {
            printer.append("\n**********\n");
            if (newRec) {
                printer.append(usr.simTimeStr());
                printer.append(" user: " + usr.toSynopsisString());
                printer.append("\n");
            }
            printer.append(txt);
        }
    }

    public static void trackSC(boolean newRec, String txt, SmallCell sc, boolean overrideSC) {
        if (sc.getID() == 13 || overrideSC) {
            printer.append("\n");
            if (newRec) {
                printer.append(sc.simTimeStr());
                printer.append("\n");
            }
            printer.append(txt);
        }
    }

    public static void trackUserOut(boolean newRec, String txt, CachingUser usr, boolean overrideMU) {
        if (usr.getID() == 1
                //                || usr.getID() == 7
                //                || usr.getID() == 11
                || overrideMU) {
            try {
                System.out.append("\n");
                if (newRec) {
                    System.out.append(usr.simTimeStr());
                    System.out.append("\n");
                }
                System.out.append(txt);
                System.out.println();
                System.in.read();

            } catch (IOException ex) {

            }
        }
    }

    public static void trackSCOut(boolean newRec, String txt, SmallCell sc, boolean overrideSC) {
        if (sc.getID() == 13 || overrideSC) {
            try {
                System.out.append("\n");
                if (newRec) {
                    System.out.append(sc.simTimeStr());
                    System.out.append("\n");
                }
                System.out.append(txt);
                System.out.println();
                System.in.read();
            } catch (IOException ex) {

            }
        }

    }

    public static void appendLog(String txt, SmallCell sc, caching.base.AbstractCachingPolicy policy) {
        if ((sc.getID() == monitorCell || monitorCell == -1) && policy.getClass() == _policy.getClass()) {
            printer.append("\n\t" + txt);
        }
    }

    public static void appendLog(String txt, CachingUser mu) {
        if (mu.getID() == 7) {
            printer.append("\n\t" + txt);
        }
    }

    public static void flushLogs() {
        printer.flush();
//        printer2.flush();
    }

    public static void closeLogs() {
        printer.close();
//        printer2.close();
    }

    /**
     * Tries to cancel each cached item requested by the mobile, unless it is
     * also cached on behalf of other mobiles.
     *
     * @param cu
     * @param policy
     * @param targetSC
     * @return the canceled requests
     */
    public static Set<Chunk> cancelCachingOrders(CachingUser cu,
            AbstractCachingPolicy policy, SmallCell targetSC) {

        Set<Chunk> itemsRmvd = new HashSet<>();

        for (Chunk nxtReqChunk : cu.getRequestsInChunks()) {
            if (targetSC.bufferContains(policy, cu, nxtReqChunk)) {
                Set<CachingUser> stillRequesting = targetSC.bufferTryEvict(cu, policy, nxtReqChunk);
                /**
                 * There may be still requesting mus, but they may be requesting
                 * with zero probability, because the item was previously
                 * cached!
                 */
                if (stillRequesting.isEmpty()) {
                    itemsRmvd.add(nxtReqChunk);
//                    Utils.trackSC(true,
//                            "chunk " + nxtReqChunk.toSynopsisString() + " "
//                            + "is evicted in cell " + targetSC.getID()
//                            + " by mobile " + cu.getID(),
//                            cu, true);
                }

            }
        }
        return itemsRmvd;
    }

    public static Set<Chunk> optForEvictionLRUAccess(ITimeBuffer lruBuffer, Chunk item) {

        long minSpaceRequired = item.sizeInBytes();
        long freeSpace = lruBuffer.availableSpaceInBytes();

        Set<Chunk> optToEvict = new HashSet<>();

        Couple<Integer, Set<Chunk>> leastRecentlyAccessed = lruBuffer.getLeastRecentlyAccessed();
        if (leastRecentlyAccessed == null) {
            return new HashSet<>();
        }
        Set<Chunk> lRUAccessedSet = new HashSet(leastRecentlyAccessed.getSecond());
        do {
            Iterator<Chunk> lruIter = lRUAccessedSet.iterator();

            while (lruIter.hasNext() && freeSpace < minSpaceRequired) {
                Chunk nxtItem = lruIter.next();
                optToEvict.add(nxtItem);
                freeSpace += nxtItem.sizeInBytes();
            }

            leastRecentlyAccessed = lruBuffer.getLeastRecentlyAccessed();
            lRUAccessedSet = new HashSet(leastRecentlyAccessed.getSecond());
        } while (!lRUAccessedSet.isEmpty() && freeSpace < minSpaceRequired);

        if (freeSpace < minSpaceRequired) {
            return new HashSet<>();// return an empty set. Cannot find enought space
        }

        return optToEvict;
    }

    /**
     * Applies to cases of naive and Oracle caching.
     *
     * @param lruMethod
     * @param mu
     * @param sc
     * @param poll
     * @return
     * @throws Throwable
     */
    public static Set<Chunk> naiveLRUCacheDecision(
            ILRURplc lruMethod, CachingUser mu, SmallCell sc, boolean poll)
            throws Throwable {
        Iterable<Chunk> chuunks = mu.getRequestsInChunks();
        Set<Chunk> reqIDsRplced = new HashSet<>();
        AbstractCachingPolicy cachingMethod = CachingPoliciesFactory.getCachingPolicy(lruMethod.toString());
        TimeBufferImpl buff = (TimeBufferImpl) sc.getBuffer(cachingMethod);

        for (Chunk nxtItem : chuunks) {
            switch (sc.cacheItemAttempt(mu, cachingMethod, nxtItem)) {
                case Success:
                    break;
                case ItemAlreadyCachedBySameMU:/*
                * Do nothing.. cachingMethod can happen in case the item requested from 
                * the same mu in the past has not been replaced so far.
                     */

                    break;
                case ItemAlreadyCachedByOtherMUs:
                    break;
                case FailItemOverUtilizes:
                    Set<Chunk> optForEviction = lruMethod.optForEviction(buff, nxtItem);
                    if (optForEviction.isEmpty()) {
                        continue;
                    }

                    for (Chunk item2evict : optForEviction) {
                        Set<CachingUser> theCachers = sc.bufferCachers(cachingMethod, item2evict);
                        for (CachingUser nxtCacher : theCachers) {
                            sc.removeCacher(nxtCacher, cachingMethod, item2evict);
                        }
                        sc.bufferForceEvict(cachingMethod, item2evict);
                        reqIDsRplced.add(item2evict);
                    }

// do not do the following because it is normal if items are bigger than buffer sizes:
//                    if (sc.cacheItemAttempt(mu, cachingMethod, nxtItem) != Success) {
//                        throw new InconsistencyException("Failed to cache item " + nxtItem
//                                + " even thought cache replacement took place for: "
//                                + util.CommonFunctions.toString(optForEviction)
//                        );
//                    }
                    break;
            }
        }
        return reqIDsRplced;
    }

    public static final boolean isSpaceAvail(AbstractCachingPolicy cachePolicy, SmallCell sc, long size) {
        return sc.buffAvailable(cachePolicy) >= size;
    }

    public static Set<Chunk> pricedLRUCacheDecision(ILRURplc lruMethod, CachingUser mu, SmallCell sc) throws Throwable {
        Iterable<Chunk> chunks = mu.getRequestsInChunks();
        Set<Chunk> itemsRplcd = new HashSet<>();
        AbstractPricing cachingMethod = (AbstractPricing) CachingPoliciesFactory.getCachingPolicy(lruMethod.toString());
        PricedTimeBuffer buff = (PricedTimeBuffer) sc.getBuffer(cachingMethod);

        for (Chunk nxtItm : chunks) {

            Chunk nxtIDToItem = nxtItm;

            Chunk nxtItem = nxtItm;

            double cachePrice = sc.cachePricePoll(false, nxtItem, cachingMethod);

            double assessed = 1.0 / nxtItem.sizeInMBs();
            if (cachingMethod instanceof AbstractEPC) {
                assessed *= ((AbstractEPC) cachingMethod).assess(mu, nxtItem, sc);
            } else if (cachingMethod instanceof AbstractPop) {
                assessed *= ((AbstractPop) cachingMethod).assess(nxtItem, sc);
            } else {
                throw new InvalidOrUnsupportedException("Unsupported caching policy type: " + cachingMethod.toString());
            }

            if (assessed >= cachePrice) {
                if (sc.isCached(cachingMethod, nxtItm)) {
                    sc.addCacher(mu, cachingMethod, nxtItm);
                    continue;
                }// otherwise, it may need to evict:

                //<editor-fold defaultstate="collapsed" desc="if cache replacement needed">
                if (isSpaceAvail(cachingMethod, sc, nxtIDToItem.sizeInBytes())) {// needs cache replacement
                    Set<Chunk> optForEviction = lruMethod.optForEviction(buff, nxtIDToItem);
                    if (optForEviction.isEmpty()) {
                        break;
                    }

                    for (Chunk item2evict : optForEviction) {
                        Set<CachingUser> bufferCachers = sc.bufferCachers(cachingMethod, item2evict);
                        for (CachingUser muCacher : bufferCachers) {
                            sc.removeCacher(muCacher, cachingMethod, item2evict);
                        }
                        if (sc.bufferForceEvict(cachingMethod, item2evict).isEmpty()) {
                            itemsRplcd.add(item2evict);
                        }
                    }
                }
                //</editor-fold>

                sc.cacheItemAttempt(mu, cachingMethod, nxtItm);
            } else if (sc.getSim().getRandomGenerator().randProbability() > 0.9) {/*
             * instead of using a cache price based only on items that have 
             * gain > price =>
                 */

                HashSet<Chunk> lrus = new HashSet(buff.LRUAccessed());// copy to avoid concurrent modificatoin exceptions
                if (lrus.isEmpty()) {
                    continue;
                }
                Chunk item2evict = lrus.iterator().next();

                Set<CachingUser> bufferCachers = sc.bufferCachers(cachingMethod, item2evict);
                if (bufferCachers != null) {
                    for (CachingUser muCacher : bufferCachers) {
                        sc.removeCacher(muCacher, cachingMethod, item2evict);
                    }
                }
                sc.bufferForceEvict(cachingMethod, item2evict);
                itemsRplcd.add(item2evict);
            }
        }
        return itemsRplcd;
    }

//    public static double assessAvgEMPC(Chunk item, SmallCell sc, AbstractPop cachePolicy) throws Throwable {
//        PCDemand.RegistrationInfo nfo = sc.dmdRegInfoPC(item);
//        double avgProb = nfo != null ? nfo.sumTransProbs() / nfo.cachingUsers().size() : 0.0;
//
//        double q = avgProb;
//        double f = sc.dmdPopularity(item.referredContentDocument(), cachePolicy);
//        double w = Utils.computeAvgW(sc);
//        //<editor-fold defaultstate="collapsed" desc="tmp commented">
////      sc.getSim().getStatsHandle().updtSCCmpt5(
////            f,
////            new UnonymousCompute5(
////                  cachePolicy, UnonymousCompute5.WellKnownTitle.F_POP
////            )
////      );
////      sc.getSim().getStatsHandle().updtSCCmpt5(
////            q,
////            new UnonymousCompute5(
////                  cachePolicy, UnonymousCompute5.WellKnownTitle.Q_POP
////            )
////      );
////</editor-fold>
//        return (q + w * f) * gainOfTransferSC(item, sc);
//    }
//
//   
//    public static double assessAvgEMC(Chunk item, SmallCell sc, AbstractEPC cachePolicy) throws Throwable {
//        PCDemand.RegistrationInfo nfo = sc.getDmdPC().getRegisteredInfo(item);
//        double prob = nfo != null ? nfo.sumTransProbs() / nfo.cachingUsers().size() : 0;
//        return prob * gainOfTransferSC(item, sc);
//    }
    public static double assessEMC(Chunk item, SmallCell sc, AbstractEPC cachePolicy) {
        PCDemand.RegistrationInfo nfo = sc.dmdRegInfoPC(item, cachePolicy);
        double Q = nfo != null ? nfo.sumTransProbs() : 0.0;

        double assessment = Q * item.gainOfTransferSCCacheHit();
        return assessment;
    }

    public static double assessEMPC(Chunk theChunk, SmallCell sc, IPop cachePolicy) {

        PCDemand.RegistrationInfo nfo = sc.dmdRegInfoPC(theChunk, (AbstractCachingPolicy) cachePolicy);
        double Q = nfo != null ? nfo.sumTransProbs() : 0.0;
        double f = sc.dmdPopularity(theChunk.referredContentDocument(), cachePolicy);
        double w = sc.getDmdLclForW().computeAvgW();

        if (w == -1) {
            w = 0;
            //hack.. 
        }

        double assessment = (Q + w * f) * theChunk.gainOfTransferSCCacheHit();
        //<editor-fold defaultstate="collapsed" desc="tmp commented">
//@todo commented to save computation      sc.getSim().getStatsHandle().updtSCCmpt5(
//            f,
//            new UnonymousCompute5(
//                  this, UnonymousCompute5.WellKnownTitle.F_POP
//            )
//      );
//      sc.getSim().getStatsHandle().updtSCCmpt5(
//            q,
//            new UnonymousCompute5(
//                  this, UnonymousCompute5.WellKnownTitle.Q_POP
//            )
//      );
//</editor-fold>
        return assessment;
    }

    public static double assessEPC_with_Pop(CachingUser cu, Chunk item, SmallCell sc,
            IPop cachePolicy) {

        double q = 0.0;
        if (cu == null) {
            q = 0.0;
        } else {

            if (cu instanceof MobileUser) {
                q = sc.simCellRegistry().handoffProbability((MobileUser) cu, cu.getCurrentlyConnectedSC(), sc);
            }
            if (cu instanceof StationaryUser) {
                q = 1.0;
            }

            throw new UnsupportedOperationException();

        }
        
        double f = sc.dmdPopularity(item.referredContentDocument(), cachePolicy);
        double w = sc.getDmdLclForW().computeAvgW();

        return (q + w * f) * item.gainOfTransferSCCacheHit();
    }

    public static double assessOnlyPop(AbstractPop cachePolicy, Chunk item,
            SmallCell sc) {
        double f = sc.dmdPopularity(item.referredContentDocument(), cachePolicy);
        return f * item.gainOfTransferSCCacheHit();
    }

    public static double assessEPC(CachingUser cu, Chunk item, SmallCell sc) {
        double prob = 1.0;

        if (cu instanceof MobileUser) {
            prob = sc.simCellRegistry().handoffProbability((MobileUser) cu, cu.getCurrentlyConnectedSC(), sc);
            return prob * item.gainOfTransferSCCacheHit();
        }
        if (cu instanceof StationaryUser) {
            return item.gainOfTransferSCCacheHit();
        }

        throw new CriticalFailureException(new WrongOrImproperArgumentException());
    }

    public static String toMB(double bytes) {
        return "" + (bytes / 1024.0 / 1024.0);
    }

    public static String toMB(long bytes) {
        return "" + (bytes / 1024.0 / 1024.0);
    }

}
