package caching.incremental;

import caching.base.AbstractNaive;
import caching.interfaces.incremental.IIncrementalBase;
import caching.interfaces.rplc.IGainNoRplc;
import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import sim.run.SimulationBaseRunner;
import sim.content.Chunk;
import sim.content.ContentDocument;
import static sim.space.cell.smallcell.BufferBase.BufferAllocationStatus.Success;
import sim.space.cell.smallcell.SmallCell;
import sim.space.users.CachingUser;

/**
 * @author xvas
 */
public class Naive extends AbstractNaive implements IGainNoRplc, IIncrementalBase {

    private static final Naive SINGLETON = new Naive();

    public static Naive instance() {
        return SINGLETON;
    }

    protected Naive() {
    }

    @Override
    public String nickName() {
        return getClass().getSimpleName();
    }

    @Override
    public int cacheDecision(
            SimulationBaseRunner sim, CachingUser cu, Collection<Chunk> requestedChunks,
            SmallCell hostSC, SmallCell targetSC) throws Throwable {

//        DebugTool.appendLn("requestedChunks=" + requestedChunks.size());
        // find requested objects to ignore chunks prediction and request the whole object from begining to end
        Map<Long, Chunk[]> wholeDocuments = new HashMap<>();
        Map<Long, Integer> countChunks = new HashMap<>();
        for (Chunk nxtChunk : requestedChunks) {

            ContentDocument doc = nxtChunk.referredContentDocument();

            // increase counter
            Integer c = null;

            if ((c = countChunks.get(doc.getID())) == null) {
                countChunks.put(doc.getID(), 1);
            } else {
                countChunks.put(doc.getID(), c + 1);
            }

            if (wholeDocuments.containsKey(doc.getID())) {
                continue;
            }
            Collection<Chunk> chunks = doc.chunks();
            Chunk[] arr = new Chunk[chunks.size()];
            chunks.toArray(arr);

            wholeDocuments.put(doc.getID(), arr);
        }
//////////////////////////
//////////////////////////
//////////////////////////

        int totalSizeCached = 0;

        for (Map.Entry<Long, Chunk[]> entry : wholeDocuments.entrySet()) {
            Long docID = entry.getKey();
            Chunk[] nxtChunksArr = entry.getValue();

            // this is how many will manage to get cached until the caching user 
            // is handed over to this hostSC
            Integer maxChunks = countChunks.get(docID);

            for (Chunk nxtChunk : nxtChunksArr) {
                if (maxChunks == 0) {
                    break;
                }

//                DebugTool.appendLn("maxChunks=" + maxChunks + " for doc " + docID);
                maxChunks--;

                if (targetSC.isCached(this, nxtChunk)) {
                    targetSC.addCacher(cu, this, nxtChunk);
                    continue;
                }

//xxx                if (targetSC.cacheItemAttempt(cu, this, nxtChunk) == Success) {
//                    totalSizeCached += nxtChunk.sizeInBytes();
//                }
                totalSizeCached += nxtChunk.sizeInBytes();
                targetSC.cacheItem(cu, this, nxtChunk);

            }
        }
        return totalSizeCached;
    }

}
