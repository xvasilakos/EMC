package sim;

import caching.Utils;
import caching.base.AbstractCachingPolicy;
import caching.interfaces.rplc.IGainRplc;
import exceptions.CriticalFailureException;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import sim.space.cell.smallcell.SmallCell;
import sim.space.users.mobile.MobileUser;
import sim.time.NormalSimulationEndException;
import stats.StatisticException;
import sim.space.users.StationaryUser;

/**
 *
 * @author Xenofon Vasilakos xvas@aueb.gr
 */
public final class MobProbSimulation extends Simulation {

    public MobProbSimulation(Scenario scenarioSetup) throws CriticalFailureException {
        super(scenarioSetup);
    }

    @Override
    @SuppressWarnings("empty-statement")
    public void run() {
        try { // out-of-while try: catches all types of exceptions

            while (!Thread.currentThread().isInterrupted()
                    && run_isDuringWarmupPeriod(getTrcLoader())) {
                _clock.tick();
            };

            /*
             * if warmup period has passed..
             */
            WHILE_THREAD_NOT_INTERUPTED:
            while (!Thread.currentThread().isInterrupted()) {
                _clock.tick();

//////////////////////////////////////////////////                
//yyy                run_goldenRatioSearchEPCLC();
//////////////////////////////////////////////////
                if (stationaryRequestsUsed()) {/*
                     * Concume data and keep gain stats for stationary users
                     */
                    for (SmallCell nxtSC : smallCells()) {
                        StationaryUser nxtSU = nxtSC.getStationaryUser();
                        nxtSU.consumeData(1);
                        nxtSC.updtLclDmdByStationary(false);
                    }
                }

/////////////////////////////////////
                List<MobileUser> shuffldMUs = shuffledMUs();
                _haveExitedPrevCell.clear();
                getStatsHandle().resetHandoverscount();

                for (MobileUser nxtMU : shuffldMUs) {
                    nxtMU.move(false, false);
                    nxtMU.consumeData(1);// consume in one simulation time step
                }// for all all MUs

                getStatsHandle().statHandoversCount();
/////////////////////////////////////

                for (AbstractCachingPolicy nxtPolicy : _cachingPolicies) {/*
                     * update priority queues of cached chunks for each
                     * IGainRplc replacement policy, in every small cell.
                     */
                    if (!(nxtPolicy instanceof IGainRplc)) {
                        continue;
                    }
                    IGainRplc gainRplcPolicy = (IGainRplc) nxtPolicy;
                    for (SmallCell sc : smallCells()) {
                        sc.updtCachedChunksOrderedByGain(gainRplcPolicy);
                    }
                }

/////////////////////////////////////////////////                
                for (MobileUser nxtMU : _haveExitedPrevCell) {
                    SmallCell lastSCForCacheDecisions = nxtMU.getLastSCForCacheDecisions();
                    if (lastSCForCacheDecisions != null) {
                        getStatsHandle().updtGainStats(nxtMU);
                        // cancel past PC decisions
                        nxtMU.cancelAndDeregisterPCOrders();
                    }

                    if (usesTraceOfRequests()) {
                        nxtMU.clearRequests();
                        loadNewRequestsFromWorkload(nxtMU, _dmdTrcReqsLoadedPerUser);
                    }

                    // finaly take caching decisions
                    nxtMU.cacheDescisionsPerformRegisterPC(nxtMU.getLastKnownConnectedSC());
                }

////////////////////////////////////////////////////
                boolean roundCommited = run_updtStats4SimRound();
                if (roundCommited) {
                    for (SmallCell nxtSC : simCellRegistry().cellsRegistered()) {
                        nxtSC.updtAvgHandoverDuration();
                    }
                    getStatsHandle().appendTransient(false);
                }
            }// while simulation continues// while simulation continues// while simulation continues// while simulation continues

        } catch (NormalSimulationEndException simEndEx) {
            Logger.getLogger(MobProbSimulation.class.getCanonicalName()).log(
                    Level.INFO, "Simulation {0} ended: {1}",
                    new Object[]{
                        Thread.currentThread().getName(),
                        simEndEx.getMessage()
                    });
        } catch (Throwable ex) {
            Logger.getLogger(MobProbSimulation.class.getCanonicalName())
                    .log(Level.SEVERE, "Simulation " + getID()
                            + " terminates unsuccessfully at time " + simTime(),
                            new CriticalFailureException(ex));
        } finally {

            Utils.closeLogs();
            try {
                Logger.getLogger(MobProbSimulation.class.getCanonicalName()).log(
                        Level.INFO,
                        "Printing results for simulation {0}.",
                        new Object[]{Thread.currentThread().getName()}
                );
                getStatsHandle().prntAggregates();
                getStatsHandle().appendTransient(true);
            } catch (StatisticException ex) {
                Logger.getLogger(MobProbSimulation.class.getName())
                        .log(Level.SEVERE, "Unsuccessful effort to print results.", ex);
            }
            decreaseRunningSimulations();
        }
    }

}
