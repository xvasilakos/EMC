package sim;

import app.SimulatorApp;
import app.properties.Networking;
import app.properties.Space;
import app.properties.StatsProperty;
import app.properties.valid.Values;
import caching.MaxPop;
import caching.base.AbstractCachingPolicy;
import caching.incremental.Oracle;
import exceptions.CriticalFailureException;
import exceptions.InconsistencyException;
import exceptions.InvalidOrUnsupportedException;
import exceptions.WrongOrImproperArgumentException;
import java.io.IOException;
import java.lang.reflect.Constructor;
import java.lang.reflect.InvocationTargetException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.SortedMap;
import java.util.SortedSet;
import java.util.TreeMap;
import java.util.logging.Level;
import static java.util.logging.Level.INFO;
import java.util.logging.Logger;
import logging.LoggersRegistry;
import sim.content.Chunk;
import sim.space.Area;
import sim.content.request.DocumentRequest;
import sim.space.cell.CellRegistry;
import sim.space.connectivity.ConnectionStatusUpdate;
import sim.space.cell.MacroCell;
import sim.space.cell.smallcell.SmallCell;
import sim.time.AbstractClock;
import sim.time.NormalSimulationEndException;
import stats.StatisticException;
import stats.handlers.iterative.sc.cmpt6.UnonymousCompute6;
import sim.content.ContentDocument;
import sim.space.users.CachingUser;
import sim.space.users.mobile.MobileGroupsRegistry;
import sim.space.users.mobile.MobileUser;
import traces.dmdtrace.TraceLoader;
import traces.dmdtrace.TraceWorkloadRecord;
import util.random.RandomGeneratorWrapper;

/**
 *
 * @author Xenofon Vasilakos xvas@aueb.gr
 * @param <M>
 */
public abstract class SimulationBase<M extends MobileUser> implements Runnable, ISimulationMember {

    public static final ThreadGroup SIMULATION_WORKERS_GROUP = new ThreadGroup("Parallel Simulations");
    public static final Object NONE = new Object();

    protected static int _idGen = 0;

   
    protected final int _id = ++_idGen;
    protected static final Object CONCURRENT_LOCK = new Object();
    protected static int runningSimulations = 0;

    /**
     * The parameters setup for this simulation.
     */
    protected final Scenario _scenarioSetup;

    protected final long _chunkSizeInBytes;
    protected final long _rateMCWlessInBytes;
    protected final long _rateSCWlessInBytes;
    protected final long _rateBHInBytes;

    /**
     * Then simulated _area where the cells and the mobiles are placed.
     */
    protected final Area _area;
    /**
     * A registry for the cells involved in this _sim.
     */
    protected final CellRegistry _cellRegistry;
    /**
     * A registry that contains the different groups of mobile users.
     */
    protected final MobileGroupsRegistry _musGrpsRegistry;
    /**
     * The list of all mobile users in the _sim.
     *
     * @Caution Use access methods for this list rather than the list directly.
     * The list keeps the order that the mobiles where created and thus may lead
     * to simulation synchronization phenomena regarding mobile users' mobility,
     * handoffs etc..
     */
    protected final List<M> _mblUsrs;
    /**
     * The _sim "clock" which keeps the _sim simTime "ticking".
     */
    protected final AbstractClock _clock;
    ///////////
    protected final LoggersRegistry _loggers;
    protected final StatsHandling _statsHandle;
    protected final String _decimalFormat;
    /**
     * Main caching method simulated.
     */
    protected final List<AbstractCachingPolicy> _cachingPolicies;
    protected int _warmupPeriod;
    /**
     * Contains one or more entries referring to the documents of a workload.
     */
    protected List<String> _dmdTraceDocs;
    /**
     * Contains one or more entries referring to the workload of a trace,
     * corresponding to the documents in _dmdTraceDocs
     */
    protected List<String> _dmdTraceWkrlds;
    protected int _dmdTraceLimit;
    protected final boolean _shuffleWorkloadTimes;
    protected final boolean _randInitInTrace;

    // the follwing fields are used in cases of using a trace of requests demand. 
    protected int _wrkloadLoaded;
    protected int _dmdTrcReqsLoadedPerUser;
    protected TraceLoader _trcLoader;
    /**
     * A map with the loaded request records from the workload file mapped to
     * the time of request in the workload file.
     */
    protected SortedMap<Double, TraceWorkloadRecord> _wrkLoad;
    protected Map<Long, ContentDocument> _trcDocs;

    /**
     * Defines how to compute popularity of items. This feature is used for
     * caching method decisions which use the popularity either to cache or to
     * replace a cached item.
     */
    protected String _itemPopCmptType;
    protected final String _overideItemSize;
    protected final int _loggingSimTimePeriod;
    protected final List<MobileUser> _haveExitedPrevCell = new ArrayList();
    protected Logger LOGGER;
    private String _neighborhoodType;

    /////////////////////////////////////
    /////////////////////////////////////
    /////////////////////////////////////
    /**
     * Shuffles mobile users iff _sim properties impose shuffling always before
     * using mobile users; in any case, returns the list of mobile users as an
     * unmodifiable list.
     *
     * @note to deactivate shuffling with every invocation to this method, use
     * property values "never" or "upon_creation"
     *
     * @return a possibly shuffled unmodifiable list of mus.
     */
    public List<M> shuffledMUs() {
        switch (getScenario().stringProperty(Space.MU__SHUFFLE)) {
            //<editor-fold defaultstate="collapsed" desc="shuffle iff property imposed">
            case Values.NEVER:
            case Values.UPON_CREATION:
                break; // do not shufle
            case Values.ALWAYS:
                Collections.shuffle(_mblUsrs, getRandomGenerator().getMersenneTwister());
                break;
            default:
                throw new UnsupportedOperationException(
                        getScenario().stringProperty(Space.MU__SHUFFLE) + " not supported for " + " property " + Space.MU__SHUFFLE
                );
        }
        //</editor-fold>
        return Collections.unmodifiableList(_mblUsrs);
    }

    @Override
    public final int simTime() {
        return _clock.simTime();
    }

    @Override
    public String simTimeStr() {
        return "[" + simTime() + "]";
    }

    @Override
    public final int simID() {
        return this.getID();
    }

    /**
     * This method simply returns a reference to the current _sim itself. This
     * method is implemented as part of the corresponding interface implemented.
     *
     * @return a reference to the current _sim itself.
     */
    @Override
    public final SimulationBase getSim() {
        return this;
    }

    @Override
    public final CellRegistry simCellRegistry() {
        return getSim().getCellRegistry();
    }

    /**
     * @return the list of caching methods used.
     */
    public List<AbstractCachingPolicy> getCachingPolicies() {
        return Collections.unmodifiableList(_cachingPolicies);
    }

    /**
     * @return how many records from the workload have been loaded so far or -1
     * if no trace is used.
     */
    public int getWrkloadConsumed() {
        return usesTraceOfRequests() ? _wrkloadLoaded : -1;
    }

    /**
     * @return the percentage of records from the workload that have been loaded
     * so far or -1 if no trace is used.
     */
    public double getWrkloadConsumedPercent() {
        return usesTraceOfRequests()
                ? /*rounding like xx.yy%*/ ((int) (10000.0 * _wrkloadLoaded / _trcLoader.getWrkloadSize())) / 100.0
                : -1;
    }

    /**
     * @return the trace loader
     */
    public TraceLoader getTrcLoader() {
        return _trcLoader;
    }

    /**
     * @return the documents of the trace
     */
    public Map<Long, ContentDocument> pop() {
        return Collections.unmodifiableMap(getTrcDocs());
    }

    /**
     * @return how popularity of items must be computed.
     */
    public String getItemPopCmptType() {
        return _itemPopCmptType;
    }

    /**
     * @return the _statsHandle
     */
    public StatsHandling getStatsHandle() {
        return _statsHandle;
    }

    /**
     * @return the _decimalFormat
     */
    public String getDecimalFormat() {
        return _decimalFormat;
    }

    /**
     * @return the _trcDocs
     */
    public Map<Long, ContentDocument> getTrcDocs() {
        return _trcDocs;
    }

    /**
     * @param _trcDocs the _trcDocs to set
     */
    public void setTrcDocs(Map<Long, ContentDocument> _trcDocs) {
        this._trcDocs = _trcDocs;
    }

    /**
     * @return the _wrkLoad
     */
    public SortedMap<Double, TraceWorkloadRecord> getWrkLoad() {
        return _wrkLoad;
    }

    /**
     * Does not imply number of threads in "running" state. Just the number of
     * simulations that have started to run. This number is always less than a
     * threshold.
     *
     * @see getMaxRunningThreashold()
     * @return the number of currently running simulations
     */
    public static int getRunningSimulations() {
        synchronized (CONCURRENT_LOCK) {
            return runningSimulations;
        }
    }

    /**
     * Used for constructor initialization that must take place first before
     * other field assignments.
     *
     * @param setup
     */
    protected void initFirst(Scenario setup) {
        LOGGER = Logger.getLogger(getClass().getCanonicalName() + " for setup id = " + setup.getIDStr());
    }

    /**
     * Used for constructor initialization that must take place last after all
     * other field assignments.
     *
     * @param setup
     */
    protected void initLast(Scenario setup) {
    }

    protected SimulationBase(Scenario scenarioSetup) throws CriticalFailureException {
        initFirst(scenarioSetup);

        _scenarioSetup = scenarioSetup;

        try {
            //<editor-fold defaultstate="collapsed" desc="init local _sim loggers">
            _loggers = new LoggersRegistry(this, scenarioSetup, SimulatorApp._preprocessedProps);
            //</editor-fold>
            //<editor-fold defaultstate="collapsed" desc="init various scenario setup parameters">

            //  initilize the clock.. //
            _clock = scenarioSetup.initClock(this);
            int maxTime = getScenario().intProperty(app.properties.Simulation.Clock.MAX_TIME);
            int tmp = (int) (getScenario().doubleProperty(app.properties.Simulation.PROGRESS_UPDATE) * maxTime);
            _loggingSimTimePeriod = tmp == 0 ? 10 : tmp;

            // global variables for data rates
            _chunkSizeInBytes = Math.round(125000 * getSim().getScenario().doubleProperty(Networking.Rates.CHUNK_SIZE));
            _rateMCWlessInBytes = (long) (125000 * _scenarioSetup.doubleProperty(Networking.Rates.MC_WIRELESS));
            _rateSCWlessInBytes = (long) (125000 * _scenarioSetup.doubleProperty(Networking.Rates.SC_WIRELESS));
            _rateBHInBytes = (long) (125000 * _scenarioSetup.doubleProperty(Networking.Rates.SC_BACKHAUL));

            _warmupPeriod = getScenario().intProperty(Space.SC__WARMUP_PERIOD);
            _itemPopCmptType = _scenarioSetup.stringProperty(Space.ITEM__POP_CMPT);
            _decimalFormat = scenarioSetup.stringProperty(app.properties.Simulation.DecimalFormat);

            loadDmdTraceDocs(scenarioSetup);

            _overideItemSize = scenarioSetup.stringProperty(Space.MU__DMD__TRACE__OVERRIDE_SIZE);
            _dmdTraceLimit = scenarioSetup.intProperty(Space.MU__DMD__TRACE__LIMIT);
            _shuffleWorkloadTimes = scenarioSetup.isTrue(Space.MU__DMD__TRACE__SHUFFLE_WORKLOAD_TIMES);
            _randInitInTrace = scenarioSetup.isTrue(Space.MU__DMD__TRACE__RAND_INIT);

            if (_dmdTraceDocs.get(0).equalsIgnoreCase(Values.NONE)
                    || _dmdTraceDocs.get(0).equalsIgnoreCase(Values.NULL)
                    || _dmdTraceDocs.get(0).equalsIgnoreCase(Values.UNDEFINED)) {
                _dmdTraceDocs = null;
                _dmdTraceWkrlds = null;
            }

            _wrkLoad = new TreeMap<>();
            if (dmdTraceInUse()) {
                _trcLoader = new TraceLoader(this,
                        _dmdTraceDocs, _dmdTraceWkrlds,
                        _overideItemSize,
                        _dmdTraceLimit,
                        _randInitInTrace,
                        _shuffleWorkloadTimes
                );
                _trcDocs = _trcLoader.getDocuments();

                _dmdTrcReqsLoadedPerUser = (int) Math.round(_scenarioSetup.getRandomGenerator().getGaussian(
                        scenarioSetup.doubleProperty(Space.MU__DMD__TRACE__REQUESTS_PER_USER),
                        0.5)
                );
                if (_dmdTrcReqsLoadedPerUser < 0) {
                    _dmdTrcReqsLoadedPerUser = 0;
                }
            }
            //</editor-fold>
        } catch (InvalidOrUnsupportedException | IOException ex) {
            throw new CriticalFailureException(ex);
        }

        //  initilize caching methods //
        _cachingPolicies = scenarioSetup.loadCachingPolicies();

        // initialize the _area //
        _area = scenarioSetup.initArea(this);

        // itialize cells //
        Set<SmallCell> scs = scenarioSetup.initSCs(this, _area, _cachingPolicies);
        MacroCell macroCell = scenarioSetup.initMC(this, _area);

        // initilize mobile users and arrange initial connectivity and proactive caching  status //
        _musGrpsRegistry = new MobileGroupsRegistry(this);

        // initialize cells and CellRegistry //
        _cellRegistry = initSCRegistry(scenarioSetup, _musGrpsRegistry, scs, macroCell, _area);
        initCellNeighborhood(_cellRegistry, scenarioSetup);

        // initilize mobile users and arrange initial connectivity and proactive caching  status //
        _mblUsrs = initAndConnectMUs(scenarioSetup, _musGrpsRegistry, _area, _cellRegistry, getCachingPolicies());

        // initilize statistics handling //
        _statsHandle = new StatsHandling(this);

        try {
            boolean preloadAll = getScenario().isTrue(
                    app.properties.Caching.CACHING__PRELOAD__CACHES__ALL__POLICIES
            );
            preCachesMostPopDocs(scs, preloadAll);
        } catch (InvalidOrUnsupportedException | WrongOrImproperArgumentException ex) {
            Logger.getLogger(SimulationBase.class.getName()).log(Level.SEVERE, null, ex);
            throw new CriticalFailureException(ex);
        } finally {
            initLast(scenarioSetup);
        }
    }

    protected void preCachesMostPopDocs(Set<SmallCell> scs, boolean preloadAll)
            throws WrongOrImproperArgumentException {

        if (_trcLoader == null) {
            throw new CriticalFailureException("Can not run simulations for "
                    + MaxPop.class.getCanonicalName() + " when loaded requests trace is " + null);
        }
        if (preloadAll) {
            if (!_cachingPolicies.contains(MaxPop.instance())) {
                throw new WrongOrImproperArgumentException("Can not preload most popular"
                        + " documents in the cache for all policies without using "
                        + MaxPop.instance().toString()
                );
            }
            for (AbstractCachingPolicy nxtPolicy : _cachingPolicies) {
                if (nxtPolicy instanceof Oracle) {
                    continue;
                }
                preLoad(scs, nxtPolicy);
            }
        } else if (_cachingPolicies.contains(MaxPop.instance())) {
            preLoad(scs, MaxPop.instance()); // else do it only for maxPop
        }
    }

    protected void preLoad(Set<SmallCell> scs, AbstractCachingPolicy nxtPolicy) throws CriticalFailureException {
        LOGGER.log(INFO, "Preloading top most popular items for policy {0}", nxtPolicy.toString());
        int count = 0;
        int num = scs.size();

        for (SmallCell nxtSC : scs) {
            SortedSet<ContentDocument> maxPopDocuments = _trcLoader.getMaxPopDocuments();
            Iterator<ContentDocument> iterator = maxPopDocuments.iterator();

            while (nxtSC.buffAvailable(nxtPolicy) > 0 && iterator.hasNext()) {
                ContentDocument nextDoc = iterator.next();
                for (Chunk nxtChunk : nextDoc.chunks()) {
                    nxtSC.initCacheAttempt(nxtPolicy, nxtChunk);
                }
            }

            if (++count % 100 == 0) {
                LOGGER.log(INFO, "Preloading done: {0}%", Math.round(10000.0 * count / num) / 100.0);
            }
        }
    }

    protected void loadDmdTraceDocs(Scenario scenarioSetup) {

        List<String> tmp = scenarioSetup.listOfStringsProperty(Space.MU__DMD__TRACE__FILES);

        _dmdTraceDocs = new ArrayList();
        String pathPrefix = scenarioSetup.stringProperty(Space.MU__DMD__TRACE__DOCS_PATH);
        for (String nxt : tmp) {
            _dmdTraceDocs.add(pathPrefix + "/" + nxt);
        }

        _dmdTraceWkrlds = new ArrayList();
        pathPrefix = scenarioSetup.stringProperty(Space.MU__DMD__TRACE__WORKLOAD_PATH);
        for (String nxt : tmp) {
            _dmdTraceWkrlds.add(pathPrefix + "/" + nxt);
        }

    }

    protected boolean dmdTraceInUse() {
        return _dmdTraceDocs != null;
    }

//    protected ConnectionStatusUpdate run_updtSCConnStatus(M mu/*, Couple<SmallCell, SmallCell> priorPosteriorConnUpdtSCs*/)
//            throws WrongOrImproperArgumentException, InvalidOrUnsupportedException, CriticalFailureException {
//
//        /* The last known connected and pre-moving connected cells may not be the same.
//       * This can happen (and most commonly it does happen because) when the
//       * mu moves out of range of any cell between handoffs, i.e. preMoveConnSC can be null
//       * while lastKnownConnSC may not be null. If both lastKnownConnSC and preMoveConnSC
//       * null, then this situation is due to the fact that the mu was either reset or entered  
//       * the simulation for the first time.
//         */
//        SmallCell lastKnownConnSC = mu.getLastKnownConnectedSC();
////        priorPosteriorConnUpdtSCs.setFirst(lastKnownConnSC);
//        SmallCell preMoveConnSC = mu.getCurrentlyConnectedSC();
//
//        SmallCell handoffSC = null;
//        if (!mu.getCoordinates().getCoveringSCs().isEmpty()) {
//            List<String> handoffPolicy = _scenarioSetup.parseConnPolicySC();
//
//            handoffSC = CellUtilities.findHandoffcandidates(
//                    _cellRegistry, mu, handoffPolicy);
//        }
////        priorPosteriorConnUpdtSCs.setSecond(handoffSC);
//
//
//        /*
//* 6 possible combinations: two values (not null or null) for three states: 
//* lastKnownConnSC, preMoveConnSC, handoffSC under the constraint that 
//if preMoveConnSC <> null, then preMoveConnSC==lastKnownConnSC, i.e: 
//         */
//        if (preMoveConnSC != null && !preMoveConnSC.equals(lastKnownConnSC)) {
//            throw new InconsistencyException("connection befroe moving dows not coincide with connection after movinng");
//        }
//
////A: mobile is out of range of all SCs     
//// case 1: was and remains disconnected
//        if (handoffSC == null && preMoveConnSC == null) {
//            return WAS_AND_REMAINS_NEVER_CONNECTED;
//        }
//
//// case 2: Mobile got now out of range: Connection Update + NO handoff        
//        if (handoffSC == null && preMoveConnSC != null) {
//            /* Mobile got out of range: Connection Update + NO handoff
//          *
//          * If code reaches here, then there is an connectivity update but no handoff
//          * 1) handoffCandidateSC is null
//          * 2) preMoveConnSC is not null
//          *
//          * Either the mu is in transit from one cell to another, or tempory disconnection 
//          * took place and the mobile will connect again to the same cell or not.
//             */
//            mu.disconnectFromSC(); //addition now
//            return GOT_DISCONNECTED;
//        }
////
////
////
/////// B: MU__CLASS is (or remains) now in range of a small cell      
////      holds: handoffSC != null 
//
//// case B1.1: still in same SC range 
//        if (handoffSC.equals(preMoveConnSC)) {
//            /* No connectivity change betweem before moving and post moving.
//          * Stays within same cell */
//            return REMAINS_CONNECTED_TO_SAME_SC;
//        }
//
//// case B1.2: otherwise direct handoff without going through a disconnection period        
//        if (!handoffSC.equals(preMoveConnSC) && preMoveConnSC != null) {
//            mu.disconnectFromSC();
//
//            mu.connectToSC(handoffSC);
//            return HANDOVER_DIRECTLY;
//        }
//
//// case B2: returned to formerly connected SC
//        if (!handoffSC.equals(preMoveConnSC) && preMoveConnSC == null && handoffSC.equals(lastKnownConnSC)) {
//            /* the mobile user was temporarily disconnected from a given 
//          * cell for a while.*/
//
//            mu.connectToSC(handoffSC);
//            return GOT_RECONNECTED_TO_SC_AFTER_TMP_DISCON;
//        }
//
//// case B2.2: Case of handover to another cell or (if lastKnownConnSC==null) first time connection after resetting or entering the simulation.
//        if (!handoffSC.equals(preMoveConnSC) && preMoveConnSC == null && !handoffSC.equals(lastKnownConnSC)) {
//            mu.connectToSC(handoffSC);
//
//// case B2.2.1: Case of handover to another cell after roaming for a while without being connected
//            if (lastKnownConnSC != null) {
//                return HANDOVER_AFTER_DISCONNECTION_PERIOD;
//            }
//
//// case B2.2.2: Case of first time connection after resetting or entering the simulation.            
//            return CONNECTED_FIRST_TIME_TO_SC;
//
//        }
//
//        throw new InconsistencyException("execution reached to an unknown state of mobile transition after moving in the area");
//
//    }
    protected void decreaseRunningSimulations() {
        synchronized (CONCURRENT_LOCK) {
            runningSimulations--;

            LOGGER
                    .log(Level.INFO, "Simulation Thread {0} Ended! Currently running: {1}/{2}",
                            new Object[]{getID(), runningSimulations,
                                SimulatorApp.getMainArgs().getMaxConcurrentWorkers()
                            });
            CONCURRENT_LOCK.notifyAll();
        }
    }

    /**
     * @return the currSetup
     */
    public Scenario getScenario() {
        return _scenarioSetup;
    }

    /**
     * @return the _area
     */
    public Area getArea() {
        return _area;
    }

    /**
     * @return the cellLoggersRegistry
     */
    public CellRegistry getCellRegistry() {
        return _cellRegistry;
    }

    public RandomGeneratorWrapper getRandomGenerator() {
        return getScenario().getRandomGenerator();
    }

    public MacroCell macrocell() {
        return this.getCellRegistry().getMacroCell();
    }

    public Collection<SmallCell> smallCells() {
        return this.getCellRegistry().cellsRegistered();
    }

    public int getID() {
        return _id;
    }

    /**
     * Launches a sim worker-thread.
     *
     * @param setup Set of parameters that define the scenario setup
     * @return a reference to the _sim worker-thread that has just been started.
     */
    public static Thread launchSimulationThread(Scenario setup) {
        try {

            waitMaxThreadsThreshold();

            String classSimName = setup.stringProperty(Space.MU__CLASS);
            Class simClass = Class.forName(classSimName);
            Constructor constructor = simClass.getConstructor(Scenario.class);

            SimulationBase simRnbl = (SimulationBase) constructor.newInstance(setup);

            String simID = classSimName + "#" + String.valueOf(simRnbl.getID());
            Thread simThread = new Thread(SIMULATION_WORKERS_GROUP, simRnbl, simID);
            simThread.start();

            return simThread;
        } catch (ClassNotFoundException | NoSuchMethodException |
                SecurityException | InstantiationException |
                IllegalAccessException | IllegalArgumentException |
                InvocationTargetException e) {
            throw new CriticalFailureException(e);
        }
    }

    /**
     * Wait while the maximum number of concurrently running working threads is
     * reached.
     *
     * The maximum number of concurrently running worker-threads cannot not
     * exceed the threshold defined in the main method arguments.
     *
     * @throws InterruptedException
     */
    protected static void waitMaxThreadsThreshold() {
        //<editor-fold defaultstate="collapsed" desc="enforce max concurrent workers threshold">
        synchronized (CONCURRENT_LOCK) {
            int maxConcurrentWorkers = SimulatorApp.getMainArgs().getMaxConcurrentWorkers();
            while (maxConcurrentWorkers <= runningSimulations) {
                try {
                    CONCURRENT_LOCK.wait();
                } catch (InterruptedException ex) {
                    throw new CriticalFailureException(
                            "Concurency lock for not exceeding the maximum number of workers was interrupted unxpectedly", ex);
                }
            }
            runningSimulations++;
        }
    }

    public MobileGroupsRegistry getGroupsRegistry() {
        return _musGrpsRegistry;
    }

    /**
     * @return the _warmupPeriod
     */
    public int getWarmupPeriod() {
        return _warmupPeriod;
    }

    public boolean runUpdtStats4SimRound() throws StatisticException {
        if (!getStatsHandle().isStatsMinTimeExceeded()) {
            return false;
        }

        getStatsHandle().updtIterativeSCCmpt4();
        getStatsHandle().updtIterativeSCCmpt4NoCachePolicy();
        getStatsHandle().updtFixedSC();
        return getStatsHandle().tryCommitRound();
    }

    protected boolean isDuringWarmupPeriod(TraceLoader trcLoader)
            throws InconsistencyException, CriticalFailureException,
            IOException, InvalidOrUnsupportedException, WrongOrImproperArgumentException, Throwable {

        if (simTime() < _warmupPeriod) {
            runWarmUpVars();
            return true;
        } else if (simTime() == _warmupPeriod) {
            runWarmUpVars();
            /* When simTime() == _warmupPeriod, reset and prepear all mobiles.
             */
            if (stationaryRequestsUsed()) {
                for (SmallCell nxtSC : getCellRegistry().cellsRegistered()) {
                    nxtSC.initLclDmdStationary();
                    nxtSC.updtLclDmdByStationary(true);
                }
            }
            for (M nxtMU : _mblUsrs) {
                if (usesTraceOfRequests()) {
                    loadNewRequestsFromWorkload(nxtMU, _dmdTrcReqsLoadedPerUser);
                }
            }
            return true;
        }
        return false;
    }

    protected void runWarmUpVars()
            throws InvalidOrUnsupportedException,
            WrongOrImproperArgumentException, CriticalFailureException, StatisticException {

/////////////////////////////////////
        getStatsHandle().resetHandoverscount();
        _haveExitedPrevCell.clear();

        for (M nxtMU : _mblUsrs) {
            ConnectionStatusUpdate updtSCConnChange = nxtMU.move(false, true);
            if (updtSCConnChange.isHandedOver()) {
                nxtMU.getPreviouslyConnectedSC().addNeighbor(nxtMU.getCurrentlyConnectedSC());
            }
        }
        getStatsHandle().statHandoversCount();
/////////////////////////////////////

        boolean roundCommited = runUpdtStats4SimRound();
        if (roundCommited) {
            getStatsHandle().appendTransient(false);
        }
    }

    //yyy keep this, only update stat code for gain which must be used
    protected void runGoldenRatioSearchEMPCLC() throws Exception {

        // check if needed
        if (!_cachingPolicies.contains(caching.rplc.mingain.tuned.EMPC_LC_Tunned_a.instance())
                || simTime() <= getSim().getScenario().intProperty(StatsProperty.STATS__MIN_TIME)) {
            return;
        }

        /*
       * Every once in a while, check for re-adjusting
       *
         */
        Collection<SmallCell> cellsRegistered = getCellRegistry().cellsRegistered();
        for (SmallCell nxtSC : cellsRegistered) {
            if (simTime() % nxtSC.getEPCLCnoRplcState().getReadjustmenyPeriod() != 0) {
                break;
            }
            /* otherwise:
          *1) Re-adjust time intervals based on golden ratio search.
          *2) Then, resetGains gains maintained
             */

            SmallCell.EPCLCnoRplcState epcLCnoRplcState = nxtSC.getEPCLCnoRplcState();

            if (epcLCnoRplcState.isOptimumFound()) {
                continue;
            }

            //1
            double a = epcLCnoRplcState.getA();
            double b = epcLCnoRplcState.getB();
            double c1 = epcLCnoRplcState.getC1();
            double c2 = epcLCnoRplcState.getC2();

            double f_a = epcLCnoRplcState.getGainA();
            double f_b = epcLCnoRplcState.getGainB();
            double f_c1 = epcLCnoRplcState.getGainC1();
            double f_c2 = epcLCnoRplcState.getGainC2();

            getStatsHandle().updtSCCmpt6(a,
                    new UnonymousCompute6(
                            UnonymousCompute6.WellKnownTitle.GOLDEN_RATIO_A)
            );
            getStatsHandle().updtSCCmpt6(c1,
                    new UnonymousCompute6(
                            UnonymousCompute6.WellKnownTitle.GOLDEN_RATIO_C1)
            );
            getStatsHandle().updtSCCmpt6(c2,
                    new UnonymousCompute6(
                            UnonymousCompute6.WellKnownTitle.GOLDEN_RATIO_C2)
            );
            getStatsHandle().updtSCCmpt6(b,
                    new UnonymousCompute6(
                            UnonymousCompute6.WellKnownTitle.GOLDEN_RATIO_B)
            );

            getStatsHandle().updtSCCmpt6(f_a,
                    new UnonymousCompute6(
                            UnonymousCompute6.WellKnownTitle.GOLDEN_RATIO_F_A)
            );
            getStatsHandle().updtSCCmpt6(f_c1,
                    new UnonymousCompute6(
                            UnonymousCompute6.WellKnownTitle.GOLDEN_RATIO_F_C1)
            );
            getStatsHandle().updtSCCmpt6(f_c2,
                    new UnonymousCompute6(
                            UnonymousCompute6.WellKnownTitle.GOLDEN_RATIO_F_C2)
            );
            getStatsHandle().updtSCCmpt6(f_b,
                    new UnonymousCompute6(
                            UnonymousCompute6.WellKnownTitle.GOLDEN_RATIO_F_B)
            );

            if (f_c1 < f_c2) {// then the maximum must lie on [c1, b], so assign a = c1.
                epcLCnoRplcState.setA(c1);
                epcLCnoRplcState.recomputeC1C2();

                if (Math.abs(epcLCnoRplcState.getA() - epcLCnoRplcState.getB()) < epcLCnoRplcState.getStopE()) {
                    epcLCnoRplcState.markOptimumFound();
                }
                epcLCnoRplcState.resetGains();
            } else if (f_c1 > f_c2) { // Then the maximum must lie on [a, c2], so assign b = c2.
                epcLCnoRplcState.setB(c2);
                epcLCnoRplcState.recomputeC1C2();

                if (Math.abs(epcLCnoRplcState.getA() - epcLCnoRplcState.getB()) < epcLCnoRplcState.getStopE()) {
                    epcLCnoRplcState.markOptimumFound();
                }
                epcLCnoRplcState.resetGains();
            } // else do not reset, wait for the other round..

        }//for ever SC

    }

    /**
     *
     * @param cu
     * @param loadPerUser
     * @throws java.io.IOException
     * @throws sim.time.NormalSimulationEndException
     */
    public void loadNewRequestsFromWorkload(CachingUser cu, int loadPerUser)
            throws IOException, NormalSimulationEndException {
        int i = loadPerUser;

        do {
            loadFromWrkloadIfNeeded(loadPerUser * _mblUsrs.size());
            Iterator<Map.Entry<Double, TraceWorkloadRecord>> iterator = _wrkLoad.entrySet().iterator();
            while (iterator.hasNext() && i-- > 0) {
                TraceWorkloadRecord nxtWorkloadRecord = iterator.next().getValue();

                DocumentRequest loadedRequest = new DocumentRequest(nxtWorkloadRecord, cu);

                iterator.remove();
                cu.addRequest(loadedRequest);

                //commented out to allow loading the same request ids from same mobile which resemble many mobiles during a simulation.     
                // need to also change requests collection in M to a hashset.
                //         if (nxtMU.addRequest(itemRequest)) {
                //            iterator.remove();
                //         } else {
                //            i++;// just ignore this request for this item and let it in the workload for the next mu
                //         }
            }
        } while (i > 0);

        cu.updtLastTimeReqsUpdt();
    }

    public boolean stationaryRequestsUsed() {
        return getScenario().intProperty(Space.SC__DMD__TRACE__STATIONARY_REQUESTS__RATE) > 0;
    }

    public boolean usesTraceOfRequests() {
        return _dmdTraceDocs != null;
    }

    /**
     * Loads to the workload map more records if necessary, and prints updates
     * to the user
     *
     * @param threshold
     * @throws IOException
     * @throws NormalSimulationEndException in case all the requests in the
     * trace were loaded.
     */
    public void loadFromWrkloadIfNeeded(int threshold)
            throws IOException, NormalSimulationEndException {

        if (_wrkLoad.size() < threshold) { // just to be sure enough are loaded
            SortedMap<Double, TraceWorkloadRecord> loaded
                    = _trcLoader.loadFromWorkload(2 * threshold);
            _wrkloadLoaded += loaded.size();
            _wrkLoad.putAll(loaded);
            if (_wrkLoad.isEmpty()) {// if still empty
                LOGGER.log(
                        Level.INFO, "\n\t* Workload for trace has finished. "
                        + "\n\t* Simulation {0} ended normaly.\n\t*"
                        + "\n\t* Printing results.\n",
                        new Object[]{_scenarioSetup.getIDStr()});
                throw new NormalSimulationEndException("Workload is finished:\n"
                        + "\t* All rerquests from trace were loaded."
                );
            }
        }

    }

    @Override
    public int hashCode() {
        return _id;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        final SimulationBase other = (SimulationBase) obj;
        return this._id == other._id;
    }

    public long chunkSizeInBytes() {
        return _chunkSizeInBytes;
    }

    /**
     * @return the _rateMCWlessInBytes
     */
    public long getRateMCWlessInBytes() {
        return _rateMCWlessInBytes;
    }

    public long getRateMCWlessInChunks() {
        return Math.round(_rateMCWlessInBytes / _chunkSizeInBytes);
    }

    /**
     * @return the _rateSCWlessInBytes
     */
    public long getRateSCWlessInBytes() {
        return _rateSCWlessInBytes;
    }

    public long getRateSCWlessInChunks() {
        return Math.round(_rateSCWlessInBytes / _chunkSizeInBytes);
    }

    /**
     * @return the _rateBHInBytes
     */
    public long getRateBHInBytes() {
        return _rateBHInBytes;
    }

    public long getRateBHInChunks() {
        return Math.round(_rateBHInBytes / _chunkSizeInBytes);
    }

    public final int loggingSimTimePeriod() {
        return _loggingSimTimePeriod;
    }

    List<SmallCell> monitorSCs() {
        List<Integer> cellIDs = getScenario().listOfIntegersProperty(StatsProperty.STATS__HANLDERS__FIXED_SC__MONITOR_SCS);
        List<SmallCell> cells = new ArrayList();
        for (int i = 0; i < cellIDs.size(); i++) {
            Integer nxtID = cellIDs.get(i);
            cells.add(_cellRegistry.getCellByID(nxtID));
        }

        return cells;
    }

    public void addHaveExitedPrevCell(MobileUser muExitedCell) {
        _haveExitedPrevCell.add(muExitedCell);
    }

    public void removeHaveExitedPrevCell(MobileUser muExitedCell) {
        _haveExitedPrevCell.remove(muExitedCell);
    }

    /**
     * Initializes mobile users on the area.
     *
     * @param scenario
     * @param ugReg
     * @param area
     * @param scReg
     * @param cachingPolicies
     * @return
     */
    abstract protected List<M> initAndConnectMUs(
            Scenario scenario, MobileGroupsRegistry ugReg,
            Area area, CellRegistry scReg,
            Iterable<AbstractCachingPolicy> cachingPolicies);

    protected void initCellNeighborhood(CellRegistry reg, Scenario setup) {
        _neighborhoodType = setup.stringProperty(app.properties.Space.SC__NEIGHBORHOOD);
        switch (_neighborhoodType) {
            case Values.ALL_PLUS_SELF:
                
                for (SmallCell scI : reg.cellsRegistered()) {
                    for (SmallCell scJ : reg.cellsRegistered()) {
                        if (!scI.equals(scJ)) {
                            scI.addNeighbor(scJ);
                        }
                    }
                }
                break;

            case Values.ALL:
                for (SmallCell scI : reg.cellsRegistered()) {
                    for (SmallCell scJ : reg.cellsRegistered()) {
                        scI.addNeighbor(scJ);
                    }
                }
                break;

            case Values.BUILD:
                return;// do nothing in this case

            default:
                throw new UnsupportedOperationException(
                        "Value " + _neighborhoodType
                        + " is not supported. Check for wrong parameter value set for property \""
                        + app.properties.Space.SC__NEIGHBORHOOD
                        + "\""
                );

        }
    }

    protected CellRegistry initSCRegistry(Scenario setup, MobileGroupsRegistry groupsRegistry,
            Set<SmallCell> scs, MacroCell mc, Area area) throws CriticalFailureException {
        try {
            CellRegistry reg = new CellRegistry(this, groupsRegistry, scs, mc, area);
            LOGGER.log(Level.INFO, "Cell registry initialized.\n");
            return reg;
        } catch (InvalidOrUnsupportedException ex) {
            LOGGER.log(Level.SEVERE, ex.getMessage(), ex);
            throw new CriticalFailureException(ex);
        }
    }

    /**
     * @return the _neighborhoodType
     */
    public String getNeighborhoodType() {
        return _neighborhoodType;
    }
}
