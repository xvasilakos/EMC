package sim.space.users;

import caching.MaxPop;
import caching.base.AbstractCachingPolicy;
import caching.incremental.Oracle;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import sim.run.SimulationBaseRunner;
import sim.content.Chunk;
import sim.content.request.DocumentRequest;
import sim.space.Point;
import sim.space.cell.MacroCell;
import sim.space.cell.smallcell.SmallCell;
import utilities.Couple;

/**
 *
 * @author xvas
 */
public class StationaryUser extends CachingUser {

    public StationaryUser(int id, SimulationBaseRunner sim,
            Collection<AbstractCachingPolicy> cachingPolicies) {

        super(id, sim, cachingPolicies);
    }

    public StationaryUser(int id, SimulationBaseRunner sim, int connectedSinceSC,
            SmallCell connectionSC, MacroCell connectionMC,
            Collection<AbstractCachingPolicy> cachingPolicies) {

        super(id, sim, connectedSinceSC, connectionSC, connectionMC,
                cachingPolicies);
    }

    public void cancelAndDeregisterPCOrders() {
        super.cancelAndDeregisterPCOrders(getCurrentlyConnectedSC());
    }

    /**
     * This is a stationary user. Thus, the default getCoordinates are the
     * getCoordinates of the center of the connection cell.
     *
     * @return the getCoordinates of the center of the connection cell
     */
    @Override
    public Point getCoordinates() {
        return getCurrentlyConnectedSC().getCenter();
    }

    @Override
    public void addAllRequests(Collection<DocumentRequest> requests) throws Throwable {
        for (DocumentRequest r : requests) {
            addRequest(r);
        }
    }

 

    public void cacheRecentMCandBH() throws Throwable {

        // we care to request to cacheRecentMCandBH only the ones not hit in the cacheRecentMCandBH, i.e:
        // 1) the ones from the BH
        Map<AbstractCachingPolicy, List<Chunk>> mostRecentlyConsumedBH = 
                getMostRecentlyConsumedBH();
        // 2) the ones from the MC
        Map<AbstractCachingPolicy, List<Chunk>> mostRecentlyConsumedMC = 
                getMostRecentlyConsumedMC();

//commented out the following
        for (AbstractCachingPolicy policy : getCachingPolicies()) {
            if (policy instanceof MaxPop //                    || policy instanceof Oracle
                    ) {
                // cached object stay permanently in cacheRecentMCandBH.
                continue;
            }

            List<Chunk> recentlyConsumedLst = new ArrayList();
            recentlyConsumedLst.addAll(mostRecentlyConsumedBH.get(policy));
            recentlyConsumedLst.addAll(mostRecentlyConsumedMC.get(policy));

            _currentlyConnectedSC.cacheDecisions(policy, this, _currentlyConnectedSC,
                    recentlyConsumedLst, recentlyConsumedLst//new ArrayList() /*otherwise it benefits naive too much*/
            );

        }
    }

    public void forceCompleteRequests() {
        for (DocumentRequest r : getRequests()) {
            r.forceComplete(simTime());
        }
    }

    @Override
    public void addRequest(DocumentRequest r) throws Throwable {
        super.addRequest(r);
        _currentlyConnectedSC.getPopInfo().registerPopInfo(r);
    }
}
