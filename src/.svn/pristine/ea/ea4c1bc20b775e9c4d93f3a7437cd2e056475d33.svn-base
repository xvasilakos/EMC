package sim;

import app.properties.Space;
import app.properties.valid.Values;
import caching.Utils;
import caching.base.AbstractCachingPolicy;
import caching.interfaces.rplc.IGainRplc;
import exceptions.CriticalFailureException;
import exceptions.InconsistencyException;
import exceptions.WrongOrImproperArgumentException;
import java.io.BufferedReader;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.SortedMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import sim.space.Area;
import sim.space.Point;
import sim.space.cell.CellRegistry;
import sim.space.cell.smallcell.SmallCell;
import sim.time.NormalSimulationEndException;
import stats.StatisticException;
import sim.space.users.StationaryUser;
import sim.space.users.mobile.MobileGroup;
import sim.space.users.mobile.MobileGroupsRegistry;
import sim.space.users.mobile.MobileUser;
import sim.space.users.mobile.TraceMU;
import sim.space.users.mobile.TraceMUBuilder;

/**
 *
 * @author Xenofon Vasilakos xvas@aueb.gr
 */
public final class TaxiSimulation extends SimulationBase<TraceMU> {

    private static final Logger LOGGER = Logger.getLogger(TaxiSimulation.class.getCanonicalName());
    private final BufferedReader _mubin;

    private final Map<Integer, TraceMU> _musbyID;

    public TaxiSimulation(Scenario scenarioSetup) throws CriticalFailureException {
        super(scenarioSetup);
        _musbyID = new HashMap();

        String mutracePath = getScenario().stringProperty(Space.MU__TRACE);
        try {
            _mubin = new BufferedReader(new FileReader(mutracePath));
        } catch (FileNotFoundException ioe) {
            throw new CriticalFailureException(ioe);
        }
    }

    private void updateTraceMU() throws IOException, NumberFormatException, InconsistencyException {
        String mubinLine;
        // out-of-while try: catches all types of exceptions

        int simTime = _clock.simTime();
        while ((mubinLine = _mubin.readLine()) != null) {
            String[] csv = mubinLine.split(",");
            if (csv[0].startsWith("#")) {
                continue;
            }
            if (Integer.parseInt(csv[0]) > simTime) {
                break;
            }

            int muId = Integer.parseInt(csv[1]);
            double dxdt = Double.parseDouble(csv[2]);
            double dydt = Double.parseDouble(csv[3]);

            TraceMU nxtMU = _musbyID.get(muId);
            nxtMU.setDx(dxdt);
            nxtMU.setDy(dydt);

            Utils.trackUser(true, "updated "
                    + "dxdt=" + nxtMU.getDx()
                    + "dydt=" + nxtMU.getDy(),
                    nxtMU, true);

        }
        if (mubinLine == null) {
            // the mobility trace is huge, this must never happen
            throw new InconsistencyException("the mobility trace is huge, this must never happen..");
        }
    }

    /**
     * Initializes mobile users on the setArea.
     *
     * @param scenario
     * @param ugReg
     * @param area
     * @param scReg
     * @param cachingPolicies
     * @return
     */
    @Override
    protected List<TraceMU> initAndConnectMUs(
            Scenario scenario, MobileGroupsRegistry ugReg,
            Area area, CellRegistry scReg,
            Iterable<AbstractCachingPolicy> cachingPolicies) {

        String metaPath = scenario.stringProperty(Space.MU__TRACE__META);

        List<TraceMU> musLst = new ArrayList<>();

        List<String> conn2SCPolicy;

        conn2SCPolicy = scenario.parseConnPolicySC();
        String mobTransDecisions = scenario.stringProperty(Space.MU__TRANSITION_DECISIONS);
        int itemSize = scenario.intProperty(Space.ITEM__SIZE);
        int itemRndIDRange = scenario.intProperty(Space.ITEM__RND_ID_RANGE);
        double percentage = scenario.doubleProperty(app.properties.Simulation.PROGRESS_UPDATE);
        String mobileTrace = scenario.stringProperty(Space.MU__TRACE);

        SortedMap<Integer, MobileGroup> groupsMap = ugReg.registeredGroups();

        if (groupsMap.size() != 1) {
            throw new CriticalFailureException(
                    new WrongOrImproperArgumentException(
                            "Mobile user type " + TraceMU.class.getCanonicalName()
                            + " must be used with one and only one group of mobile users."
                    ));
        }

        MobileGroup nxtGroup = groupsMap.get(groupsMap.firstKey());
        int musNum = nxtGroup.getSize();

        LOGGER.log(Level.INFO, "Initializing MUs on the area:\n\t{0}/{1}", new Object[]{0, musNum});
        int count = 0;
        int sum = (int) -percentage * 100;
        int printPer = (int) (musNum * percentage);
        printPer = printPer == 0 ? 1 : printPer; // otherwise causes arithmetic exception devide by zero in some cases

        try (BufferedReader bin = new BufferedReader(new FileReader(metaPath))) {

            String lineCSV;
            while ((lineCSV = bin.readLine()) != null) {
                if (lineCSV.startsWith("#")) {
                    continue;
                }
                
                String[] csv = lineCSV.split(",");

                int nxtMuID = Integer.parseInt(csv[0]);
                double avgdxdt = Double.parseDouble(csv[4]);
                double avgdydt = Double.parseDouble(csv[6]);

                //<editor-fold defaultstate="collapsed" desc="nxtMUBuilder">
                Point startPoint = area.getPoint(nxtGroup.getInitPos());

                TraceMUBuilder nxtMUBuilder = new TraceMUBuilder(
                        this, nxtGroup, startPoint,
                        conn2SCPolicy, cachingPolicies, avgdxdt, avgdydt
                );

                nxtMUBuilder.setId(nxtMuID);

                nxtMUBuilder.setArea(area);

                nxtMUBuilder.setTransitionDecisions(mobTransDecisions);

                int tmp;
                if (itemRndIDRange > 1) {
                    tmp = (int) (getRandomGenerator().randIntInRange(1, itemRndIDRange));
                } else {
                    tmp = nxtMuID;
                }

                TraceMU mu = nxtMUBuilder.build();
                //</editor-fold>
                musLst.add(mu);
                int id = mu.getID();
                _musbyID.put(id, mu);

                //<editor-fold defaultstate="collapsed" desc="report/log progress">
                if (++count % printPer == 0) {
                    sum += percentage * 100;
                    Logger.getLogger(Scenario.class.getCanonicalName() + " for setup id = " + scenario.getSetupID())
                            .log(Level.INFO, "\tdone:{0}%", sum);
                }
                //</editor-fold> 
            }//for every MU__CLASS in group
        } catch (IOException ex) {
            LOGGER.log(Level.SEVERE, null, ex);
        }

        //<editor-fold defaultstate="collapsed" desc="shuffle mus iff property ..">
        String muShuffling = scenario.stringProperty(Space.MU__SHUFFLE);
        switch (muShuffling) {
            case Values.NEVER:
                break; // do not shufle

            case Values.UPON_CREATION:
            case Values.ALWAYS:
                Collections.shuffle(musLst, getRandomGenerator().getMersenneTwister());
                break;
            default:
                throw new UnsupportedOperationException("Value " + muShuffling + " is currently not supported for "
                        + " property " + Space.MU__SHUFFLE);
        }
        //</editor-fold>
        return musLst;
    }

    @Override
    @SuppressWarnings("empty-statement")
    public void run() {

        try {

            while (!Thread.currentThread().isInterrupted()
                    && run_isDuringWarmupPeriod(getTrcLoader())) {
                _clock.tick();
                updateTraceMU();
            };

            /*
             * if warmup period has passed..
             */
            WHILE_THREAD_NOT_INTERUPTED:
            while (!Thread.currentThread().isInterrupted()) {
                _clock.tick();
                updateTraceMU();

//////////////////////////////////////////////////                
//yyy                run_goldenRatioSearchEPCLC();
//////////////////////////////////////////////////
                if (stationaryRequestsUsed()) {/*
                     * Concume data and keep gain stats for stationary users
                     */
                    for (SmallCell nxtSC : smallCells()) {
                        StationaryUser nxtSU = nxtSC.getStationaryUser();
                        nxtSU.consumeData(1);
                        nxtSC.updtLclDmdByStationary(false);
                    }
                }

/////////////////////////////////////
                List<TraceMU> shuffldMUs = shuffledMUs();
                _haveExitedPrevCell.clear();
                getStatsHandle().resetHandoverscount();

                for (TraceMU nxtMU : shuffldMUs) {
                    nxtMU.move(false, false);
                    nxtMU.consumeData(1);// consume in one simulation time step
                }// for all all MUs

                getStatsHandle().statHandoversCount();
/////////////////////////////////////

                for (AbstractCachingPolicy nxtPolicy : _cachingPolicies) {/*
                     * update priority queues of cached chunks for each
                     * IGainRplc replacement policy, in every small cell.
                     */
                    if (!(nxtPolicy instanceof IGainRplc)) {
                        continue;
                    }
                    IGainRplc gainRplcPolicy = (IGainRplc) nxtPolicy;
                    for (SmallCell sc : smallCells()) {
                        sc.updtCachedChunksOrderedByGain(gainRplcPolicy);
                    }
                }

/////////////////////////////////////////////////                
                for (MobileUser nxtMU : _haveExitedPrevCell) {
                    SmallCell lastSCForCacheDecisions = nxtMU.getLastSCForCacheDecisions();
                    if (lastSCForCacheDecisions != null) {
                        getStatsHandle().updtGainStats(nxtMU);
                        // cancel past PC decisions
                        nxtMU.cancelAndDeregisterPCOrders();
                    }

                    if (usesTraceOfRequests()) {
                        nxtMU.clearRequests();
                        loadNewRequestsFromWorkload(nxtMU, _dmdTrcReqsLoadedPerUser);
                    }

                    // finaly take caching decisions
                    nxtMU.cacheDescisionsPerformRegisterPC(nxtMU.getLastKnownConnectedSC());
                }

////////////////////////////////////////////////////
                boolean roundCommited = run_updtStats4SimRound();
                if (roundCommited) {
                    for (SmallCell nxtSC : simCellRegistry().cellsRegistered()) {
                        nxtSC.updtAvgHandoverDuration();
                    }
                    getStatsHandle().appendTransient(false);
                }
            }// while simulation continues// while simulation continues// while simulation continues// while simulation continues

        } catch (NormalSimulationEndException simEndEx) {
            Logger.getLogger(TaxiSimulation.class.getCanonicalName()).log(
                    Level.INFO, "Simulation {0} ended: {1}",
                    new Object[]{
                        Thread.currentThread().getName(),
                        simEndEx.getMessage()
                    });
        } catch (Throwable ex) {
            Logger.getLogger(TaxiSimulation.class.getCanonicalName())
                    .log(Level.SEVERE, "Simulation " + getID()
                            + " terminates unsuccessfully at time " + simTime(),
                            new CriticalFailureException(ex));
        } finally {

            try {
                Utils.closeLogs();

                _mubin.close();

                Logger.getLogger(TaxiSimulation.class.getCanonicalName()).log(
                        Level.INFO,
                        "Printing results for simulation {0}.",
                        new Object[]{Thread.currentThread().getName()}
                );
                getStatsHandle().prntAggregates();
                getStatsHandle().appendTransient(true);
            } catch (StatisticException ex) {
                LOGGER.log(Level.SEVERE, "Unsuccessful effort to print results.", ex);
            } catch (IOException ex) {
                LOGGER.log(Level.SEVERE, null, ex);
            }
            decreaseRunningSimulations();
        }
    }

}
