package caching.incremental;

import caching.Utils;
import caching.base.AbstractPop;
import caching.interfaces.incremental.IIncrementalAggregate;
import caching.interfaces.rplc.IGainNoRplc;
import sim.SimulationBaseRunner;
import sim.content.Chunk;
import sim.space.cell.smallcell.SmallCell;
import sim.space.users.CachingUser;

/**
 * Proactive Caching using POPularity with Cache decisions cancelation (CNC)
 * supported and no support for any cache replacement policies.
 *
 *
 * @author xvas
 */
public final class PopOnly extends AbstractPop implements IIncrementalAggregate, IGainNoRplc {

    private static final PopOnly singleton = new PopOnly();

    public static PopOnly instance() {
        return singleton;
    }

    PopOnly() {
    }

    @Override
    public double assess(Chunk item, SmallCell sc) throws Throwable {
        return Utils.assessOnlyPop(this, item, sc);
    }

    @Override
    public int cacheDecision(
            SimulationBaseRunner sim, CachingUser mu, Iterable<Chunk> requestChunks, SmallCell hostSC, SmallCell sc) throws Throwable {

        int totalSizeCached = 0;
        Iterable<Chunk> items = mu.getRequestsInChunks();
        for (Chunk nxtItem : items) {

            if (sc.isCachedBy(mu, this, nxtItem)) {
                continue;
            }

            double cachePrice = sc.cachePricePoll(false, nxtItem, this);
            if (assess(nxtItem, sc) >= cachePrice) {

                if (sc.isCached(this, nxtItem)) {
                    sc.addCacher(mu, this, nxtItem);
                    continue;
                }// otherwise, it may need to evict:

                if (!Utils.isSpaceAvail(this, sc, nxtItem.sizeInBytes())) { //since no replacement policy supported
                    continue;//cannot add this item
                }

                totalSizeCached += nxtItem.sizeInBytes();
                sc.cacheItemAttempt(mu, this, nxtItem);
            }

        }
        return totalSizeCached;
    }

}
