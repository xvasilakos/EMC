package stats;

import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import stats.Statistics.ConfidenceInterval;

/**
 * Keeps track of different statistic titles (categories) by mapping recorded values to statistics titles.
 * Values of a given statistic are recorded in an Values instance, which is mapped to the title of the
 * statistic. Note that statistics and their corresponding values are kept in lexicographical order according
 * to statistics titles.
 *
 * @author xvas
 */
public class StatsToValuesMapping {

   /**
    * key: Statistic title
    *
    * value: Values aggregated
    */
   private final Map<String, Values> statTitle_values = new TreeMap<>();
   private ConfidenceInterval confidence_interval;

   /**
    * Uses default confidence interval with 95% confidence.
    */
   public StatsToValuesMapping() {
      confidence_interval = ConfidenceInterval.Percentile_95;
   }

   /**
    * @param _confidence_interval The confidence interval percentile to use.
    */
   public StatsToValuesMapping(ConfidenceInterval _confidence_interval) {
      confidence_interval = _confidence_interval;
   }

   /**
    * @param confIntervalPercentile The confidence interval percentile to use.
    * @throws stats.StatisticException
    */
   public StatsToValuesMapping(String confIntervalPercentile) throws StatisticException {
      this(ConfidenceInterval.find(confIntervalPercentile));
   }

   /**
    *
    * @param statName
    * @param roundDecismal
    * @param value
    * @return true if recorded this statName for the first time, otherwise false
    */
   public boolean update(String statName, int roundDecismal, double... value) {
      Values aggr;
      if ((aggr = statTitle_values.get(statName)) == null) {
         statTitle_values.put(statName, new Values(roundDecismal, value));
         return true;
      }
      aggr.updt(value);
      return false;
   }

   /**
    *
    * @param statName The title of the statistic
    *
    * @return An Values instance for the particular statistic or null if no statistic such name is
    * recorded.
    */
   public Values aggregatesFor(String statName) {
      return statTitle_values.get(statName);
   }

   /**
    * @param statName The title of the statistic.
    *
    * @return The mean value of the statistic
    *
    * @throws StatisticException in case there is no record for the statistic
    */
   public double mean(String statName) throws StatisticException {
      Values aggr;
      if ((aggr = statTitle_values.get(statName)) == null) {
         throw new StatisticException(statName + " is not recorded");
      }

      return aggr.mean();
   }

   /**
    * @param statName The title of the statistic.
    *
    * @return The summary of values recorder for the particular statistic
    *
    * @throws StatisticException in case there is no record for the statistic
    */
   public double sum(String statName) throws StatisticException {
      Values aggr;
      if ((aggr = statTitle_values.get(statName)) == null) {
         throw new StatisticException(statName + " is not recorded");
      }

      return aggr.sum();
   }

   /**
    * @param statName The title of the statistic.
    *
    * @return The variance of values recorder for the particular statistic
    *
    * @throws StatisticException in case there is no record for the statistic
    */
   public double variance(String statName) throws StatisticException {
      Values aggr;
      if ((aggr = statTitle_values.get(statName)) == null) {
         throw new StatisticException(statName + " is not recorded");
      }

      return aggr.variance();
   }

   public double stddev(String statName) throws StatisticException {
      Values aggr;
      if ((aggr = statTitle_values.get(statName)) == null) {
         throw new StatisticException(statName + " is not recorded");
      }

      return aggr.stddev();
   }

   /**
    * @return the mapping between statistics titles and mapped Values instances as an unmodifiable map.
    */
   public Map<String, Values> names2aggregatesMapping() {
      return Collections.unmodifiableMap(statTitle_values);
   }

   /**
    * Returns a string representation of the mapped aggregates in the form of a table with optionally printed
    * statistics titles combined to aggregates titles as the headers of the table. A comma separated format is
    * used to form the table output.
    *
    * @param mean
    * @param variance
    * @param stddev
    * @param confInterval
     * @param statsTitles
    * @param printTitles should the titles be printed?
    * @return A string representation of the mapped aggregates in the form of a table.
    */
   public String toString_csv(
           boolean mean, boolean variance, boolean stddev, ConfidenceInterval confInterval,
           Iterable <String> statsTitles, boolean printTitles) {

      double confInterval_z = confInterval.z();
      StringBuilder _toString = new StringBuilder(180);

      //<editor-fold defaultstate="collapsed" desc="apppend the names and category of allowed stat">
      if (printTitles) {
         for (String statName : statTitle_values.keySet()) {
            if (mean) {
               _toString.append(statName).append("").append(',');
            }
            if (variance) {
               _toString.append(statName).append("(var)").append(',');
            }
            if (stddev) {
               _toString.append(statName).append("(stddev)").append(',');
            }
            if (confInterval != ConfidenceInterval.NONE) {
               _toString.append(statName).append('(').append(confInterval.getConfidencePercentile()).append(" confidence)").append(',');
            }
         }

         _toString.append('\n');
      }//titles
//</editor-fold>
      //<editor-fold defaultstate="collapsed" desc="append the values">
      for (String statName : statsTitles) {
         Values nxt_aggr = statTitle_values.get(statName);
         if (nxt_aggr == null) {
            nxt_aggr = Values.DUMMY; // in case the are no stats for this 
         }
         if (mean) {
            if (nxt_aggr == Values.DUMMY) {
               _toString.append(",");
            } else {
               _toString.append(nxt_aggr.mean()).append(",");
            }
         }
         if (variance) {
            if (nxt_aggr == Values.DUMMY) {
               _toString.append(",");
            } else {
               _toString.append(nxt_aggr.variance()).append(",");
            }
         }
         if (stddev) {
            if (nxt_aggr == Values.DUMMY) {
               _toString.append(",");
            } else {
               _toString.append(nxt_aggr.stddev()).append(",");
            }
         }
         if (confInterval != ConfidenceInterval.NONE) {
            if (nxt_aggr == Values.DUMMY) {
               _toString.append(",");
            } else {
               _toString.append(nxt_aggr.absConfInterval(confInterval_z)).append(",");
            }
         }
      }
//</editor-fold>
      return _toString.toString();
   }

   public String toString_csv_meanOnly(Iterable<String> statsTitles, boolean printTitles) {
      return toString_csv(true, false, false, ConfidenceInterval.NONE, statsTitles, printTitles);
   }

   /**
    * @return the usingZ
    */
   public double getConfidenceInterval_z() {
      return confidence_interval.z();
   }

   /**
    * Compresses (in the sense that values become garbage collectable) and finalizes state.
    */
   public void finalizeState() {
      for (Map.Entry<String, Values> entry : statTitle_values.entrySet()) {
         Values nxt_aggregatedValues = entry.getValue();
         if (nxt_aggregatedValues != Values.DUMMY) {
            nxt_aggregatedValues.finalizeState(getConfidenceInterval_z());
         }
      }
   }

   public Set<String> getTitles() {
      return this.statTitle_values.keySet();
   }

   /**
    * Ensures that the passed statistics titles are recorded, even if there are no values recorded for those
    * statistics.
    *
    * This is a useful method because there may be no record for some statistics with respect to different
    * simulation times. If that is the case, the values printed in results CSV output files are not aligned
    * correctly with statistics titles.
    *
    * For titles not already added to this instance, the title of the statistic is added with a null aggregate
    * instance (value) mapped to it.
    *
    * @param statisticsTitles
    */
   void ensureTitles(Set<String> statisticsTitles) {
      Set<String> knownTitles = statTitle_values.keySet();

      for (Iterator<String> statitle_it = statisticsTitles.iterator(); statitle_it.hasNext();) {
         String nxt_statTitle = statitle_it.next();
         if (!knownTitles.contains(nxt_statTitle)) {
            statTitle_values.put(nxt_statTitle, Values.DUMMY);
         }
      }

   }
}
