package caching.rplc.mingain;

import caching.Utils;
import caching.base.AbstractCachingPolicy;
import exceptions.InconsistencyException;
import java.util.HashSet;
import java.util.PriorityQueue;
import java.util.Set;
import sim.Simulation;
import sim.content.Chunk;
import sim.space.cell.demand_registry.PCDemand;
import sim.space.cell.smallcell.BufferBase;
import sim.space.cell.smallcell.SmallCell;
import sim.space.users.CachingUser;
import sim.space.users.StationaryUser;
import sim.space.users.mobile.MobileUser;
import sim.space.util.DistanceComparator;
import stats.handlers.iterative.sc.cmpt6.UnonymousCompute6;

/**
 * Same as EPCPop, plus tracks when proactive decisions for cache allocation
 * take place (see timeBeforeEviction() in code).
 *
 * @author Xenofon Vasilakos xvas@aueb.gr
 */
@Deprecated
public final class EPCPopTrackPC_Priced extends caching.rplc.mingain.EMPC_LC_Full_Priced {

    private static final AbstractCachingPolicy singelton = new EPCPopTrackPC_Priced();

    public static AbstractCachingPolicy instance() {
        return singelton;
    }

    EPCPopTrackPC_Priced() {
    }

    @Override
    public int cacheDecision(Simulation sim, CachingUser mu, Iterable<Chunk> requestChunks, SmallCell hostSC, SmallCell targetSC, Set<Chunk> chunksRplcd, PriorityQueue<Chunk> cachedOrderByGain) throws Throwable {

        int totalSizeCached = 0;
//        int abovePrice = 0; // counts not cached because they are above price
//        int alreadyCached = 0;

        for (Chunk nxtItem : requestChunks) {

            if (targetSC.isCachedBy(mu, this, nxtItem)) {
//                alreadyCached++;
                continue;// if already cached by this mobile user, which can happen if previously requested and then not replaced afterwards
            }

            double cachePrice = targetSC.cachePrice4Rplc(this);
            double assessment = assess(nxtItem, targetSC) / nxtItem.sizeInMBs();

            if (assessment >= cachePrice) {
                if (targetSC.isCached(this, nxtItem)) {
                    targetSC.addCacher(mu, this, nxtItem);
//                    alreadyCached++;
                    continue;
                }// otherwise, it may need to evict:

                if (!Utils.isSpaceAvail(this, targetSC, nxtItem.sizeInBytes())) {
                    /*
                     * Try evicting items
                     */

                    Set<Chunk> opt4Eviction = optForEviction(targetSC, nxtItem,
                            cachedOrderByGain);
                    if (opt4Eviction.isEmpty()) {
                        continue;//cannot add this item
                    }

                    for (Chunk item2evict : opt4Eviction) {
                        Set<CachingUser> bufferCachers = targetSC.bufferCachers(this, item2evict);
                        if (bufferCachers != null) {
                            for (CachingUser muCacher : bufferCachers) {
                                targetSC.removeCacher(muCacher, this, item2evict);
                            }
                        }

                        timeBeforeEviction(mu, targetSC, item2evict);

                        targetSC.bufferForceEvict(this, item2evict);
                        chunksRplcd.add(item2evict);
                        cachedOrderByGain.remove(item2evict);
                    }
                }// if not available space

                totalSizeCached += nxtItem.sizeInBytes();

                BufferBase.BufferAllocationStatus status = targetSC.cacheItem(mu, this, nxtItem);
                cachedOrderByGain.add(nxtItem);
                if (status == BufferBase.BufferAllocationStatus.Success) {
                    targetSC.cachePriceUpdt4Rplc(this);
                } else {
                    throw new InconsistencyException("Unsucessful allocation. Status: " + status);
                }

            }
//            else {
//                abovePrice++;
//            }
        }

//      mu.getSim().getStatsHandle().updtSCCmpt5(
//            abovePrice,
//            new UnonymousCompute5(
//                  this, UnonymousCompute5.WellKnownTitle.ITMS_NOT_CACHED_BY_PRICE
//            )
//      );
//      mu.getSim().getStatsHandle().updtSCCmpt5(
//            alreadyCached,
//            new UnonymousCompute5(
//                  this, UnonymousCompute5.WellKnownTitle.ITMS_ALREADY_CACHED
//            )
//      );
        return totalSizeCached;
    }

    private void timeBeforeEviction(CachingUser cu, SmallCell sc, Chunk item) throws Exception, Throwable {

        //////////////// keeping distance stats for mobile //////////////
        double distance = DistanceComparator.euclidianDistance(cu, sc);

        double velocity = -1;
        if (cu instanceof MobileUser) {
            velocity = ((MobileUser) cu).getVelocity();
        } else if (cu instanceof StationaryUser) {
            velocity = 0;
        } else {
            throw new UnsupportedOperationException();
        }

        double time = distance / velocity;

        int timeClass = (int) time; //strogylopoihsh
        double delayGain = 0.0;
        delayGain = item.gainOfTransferSCCacheHit();

        //<editor-fold defaultstate="collapsed" desc="comment">
//      switch (timeClass) {
//         case 0:
//            sc.getSim().getStatsHandle().updtSCCmpt6(assessment,
//                  new UnonymousCompute6(UnonymousCompute6.WellKnownTitle.RPLC_T_0_1));
//         case 1:
//            sc.getSim().getStatsHandle().updtSCCmpt6(assessment,
//                  new UnonymousCompute6(UnonymousCompute6.WellKnownTitle.RPLC_T_1_2));
//         case 2:
//            sc.getSim().getStatsHandle().updtSCCmpt6(assessment,
//                  new UnonymousCompute6(UnonymousCompute6.WellKnownTitle.RPLC_T_2_3));
//         case 3:
//            sc.getSim().getStatsHandle().updtSCCmpt6(assessment,
//                  new UnonymousCompute6(UnonymousCompute6.WellKnownTitle.RPLC_T_3_4));
//         case 4:
//            sc.getSim().getStatsHandle().updtSCCmpt6(assessment,
//                  new UnonymousCompute6(UnonymousCompute6.WellKnownTitle.RPLC_T_4_5));
//         case 5:
//            sc.getSim().getStatsHandle().updtSCCmpt6(assessment,
//                  new UnonymousCompute6(UnonymousCompute6.WellKnownTitle.RPLC_T_5_6));
//         case 6:
//            sc.getSim().getStatsHandle().updtSCCmpt6(assessment,
//                  new UnonymousCompute6(UnonymousCompute6.WellKnownTitle.RPLC_T_6_7));
//         case 7:
//            sc.getSim().getStatsHandle().updtSCCmpt6(assessment,
//                  new UnonymousCompute6(UnonymousCompute6.WellKnownTitle.RPLC_T_7_8));
//         case 8:
//            sc.getSim().getStatsHandle().updtSCCmpt6(assessment,
//                  new UnonymousCompute6(UnonymousCompute6.WellKnownTitle.RPLC_T_8_9));
//         case 9:
//            sc.getSim().getStatsHandle().updtSCCmpt6(assessment,
//                  new UnonymousCompute6(UnonymousCompute6.WellKnownTitle.RPLC_T_9_10));
//         case 10:
//            sc.getSim().getStatsHandle().updtSCCmpt6(assessment,
//                  new UnonymousCompute6(UnonymousCompute6.WellKnownTitle.RPLC_T_10_11));
//         case 11:
//            sc.getSim().getStatsHandle().updtSCCmpt6(assessment,
//                  new UnonymousCompute6(UnonymousCompute6.WellKnownTitle.RPLC_T_11_12));
//         case 12:
//            sc.getSim().getStatsHandle().updtSCCmpt6(assessment,
//                  new UnonymousCompute6(UnonymousCompute6.WellKnownTitle.RPLC_T_12_13));
//         case 13:
//            sc.getSim().getStatsHandle().updtSCCmpt6(assessment,
//                  new UnonymousCompute6(UnonymousCompute6.WellKnownTitle.RPLC_T_13_14));
//         case 14:
//            sc.getSim().getStatsHandle().updtSCCmpt6(assessment,
//                  new UnonymousCompute6(UnonymousCompute6.WellKnownTitle.RPLC_T_14_15));
//         case 15:
//            sc.getSim().getStatsHandle().updtSCCmpt6(assessment,
//                  new UnonymousCompute6(UnonymousCompute6.WellKnownTitle.RPLC_T_15_16));
//         case 16:
//            sc.getSim().getStatsHandle().updtSCCmpt6(assessment,
//                  new UnonymousCompute6(UnonymousCompute6.WellKnownTitle.RPLC_T_16_17));
//         case 17:
//            sc.getSim().getStatsHandle().updtSCCmpt6(assessment,
//                  new UnonymousCompute6(UnonymousCompute6.WellKnownTitle.RPLC_T_18_19));
//         case 18:
//            sc.getSim().getStatsHandle().updtSCCmpt6(assessment,
//                  new UnonymousCompute6(UnonymousCompute6.WellKnownTitle.RPLC_T_18_19));
//         case 19:
//            sc.getSim().getStatsHandle().updtSCCmpt6(assessment,
//                  new UnonymousCompute6(UnonymousCompute6.WellKnownTitle.RPLC_T_19_20));
//            
//         case 20:
//         case 21:
//         case 22:
//         case 23:
//         case 24:
//         case 25: {
//            sc.getSim().getStatsHandle().updtSCCmpt6(assessment,
//                  new UnonymousCompute6(UnonymousCompute6.WellKnownTitle.RPLC_T_20_25));
//         }
//         
//         case 26:
//         case 27:
//         case 28:
//         case 29:
//         case 30:
//            sc.getSim().getStatsHandle().updtSCCmpt6(assessment,
//                  new UnonymousCompute6(UnonymousCompute6.WellKnownTitle.RPLC_T_25_30));
//            
//         default:
//            sc.getSim().getStatsHandle().updtSCCmpt6(assessment,
//                  new UnonymousCompute6(UnonymousCompute6.WellKnownTitle.G_RPLC_T_30__));
//            
//      }
//</editor-fold>
        if (timeClass < 20) {

            for (int i = 0; i <= 22; i++) {
                sc.getSim().getStatsHandle().updtSCCmpt6(timeClass == i ? delayGain : 0,
                        new UnonymousCompute6(UnonymousCompute6.WellKnownTitle.titleArrRPLC_T_GAIN[i]));
            }

            for (int i = 0; i <= 22; i++) {
                sc.getSim().getStatsHandle().updtSCCmpt6(timeClass == i ? 1 : 0,//if this time class add 1, otherwise 0 so that  the stt counts numbers not average percentages
                        new UnonymousCompute6(UnonymousCompute6.WellKnownTitle.titleArrRPLC_T_NUM[i]));
            }

        } else if (timeClass < 25) {
            sc.getSim().getStatsHandle().updtSCCmpt6(delayGain,
                    new UnonymousCompute6(UnonymousCompute6.WellKnownTitle.titleArrRPLC_T_GAIN[20]));

            for (int i = 0; i < 20; i++) {
                sc.getSim().getStatsHandle().updtSCCmpt6(0,
                        new UnonymousCompute6(UnonymousCompute6.WellKnownTitle.titleArrRPLC_T_GAIN[i]));
            }

            sc.getSim().getStatsHandle().updtSCCmpt6(0,
                    new UnonymousCompute6(UnonymousCompute6.WellKnownTitle.titleArrRPLC_T_GAIN[21]));
            sc.getSim().getStatsHandle().updtSCCmpt6(0,
                    new UnonymousCompute6(UnonymousCompute6.WellKnownTitle.titleArrRPLC_T_GAIN[22]));

            for (int i = 0; i < 20; i++) {
                sc.getSim().getStatsHandle().updtSCCmpt6(0,
                        new UnonymousCompute6(UnonymousCompute6.WellKnownTitle.titleArrRPLC_T_NUM[i]));
            }

            sc.getSim().getStatsHandle().updtSCCmpt6(1,
                    new UnonymousCompute6(UnonymousCompute6.WellKnownTitle.titleArrRPLC_T_NUM[20]));

            sc.getSim().getStatsHandle().updtSCCmpt6(0,
                    new UnonymousCompute6(UnonymousCompute6.WellKnownTitle.titleArrRPLC_T_NUM[21]));
            sc.getSim().getStatsHandle().updtSCCmpt6(0,
                    new UnonymousCompute6(UnonymousCompute6.WellKnownTitle.titleArrRPLC_T_NUM[22]));

        } else if (timeClass < 30) {

            for (int i = 0; i < 21; i++) {
                sc.getSim().getStatsHandle().updtSCCmpt6(0,
                        new UnonymousCompute6(UnonymousCompute6.WellKnownTitle.titleArrRPLC_T_GAIN[i]));
            }
            sc.getSim().getStatsHandle().updtSCCmpt6(delayGain,
                    new UnonymousCompute6(UnonymousCompute6.WellKnownTitle.titleArrRPLC_T_GAIN[21]));

            sc.getSim().getStatsHandle().updtSCCmpt6(0,
                    new UnonymousCompute6(UnonymousCompute6.WellKnownTitle.titleArrRPLC_T_GAIN[22]));

            for (int i = 0; i < 21; i++) {
                sc.getSim().getStatsHandle().updtSCCmpt6(0,
                        new UnonymousCompute6(UnonymousCompute6.WellKnownTitle.titleArrRPLC_T_NUM[i]));
            }

            sc.getSim().getStatsHandle().updtSCCmpt6(1,
                    new UnonymousCompute6(UnonymousCompute6.WellKnownTitle.titleArrRPLC_T_NUM[21]));
            sc.getSim().getStatsHandle().updtSCCmpt6(0,
                    new UnonymousCompute6(UnonymousCompute6.WellKnownTitle.titleArrRPLC_T_NUM[22]));

        } else {

            for (int i = 0; i < 22; i++) {
                sc.getSim().getStatsHandle().updtSCCmpt6(0,
                        new UnonymousCompute6(UnonymousCompute6.WellKnownTitle.titleArrRPLC_T_GAIN[i]));
            }
            sc.getSim().getStatsHandle().updtSCCmpt6(delayGain,
                    new UnonymousCompute6(UnonymousCompute6.WellKnownTitle.titleArrRPLC_T_GAIN[22]));

            for (int i = 0; i < 22; i++) {
                sc.getSim().getStatsHandle().updtSCCmpt6(0,
                        new UnonymousCompute6(UnonymousCompute6.WellKnownTitle.titleArrRPLC_T_NUM[i]));
            }
            sc.getSim().getStatsHandle().updtSCCmpt6(1,
                    new UnonymousCompute6(UnonymousCompute6.WellKnownTitle.titleArrRPLC_T_NUM[22]));
        }

        sc.getSim().getStatsHandle().updtSCCmpt6(distance,
                new UnonymousCompute6(UnonymousCompute6.WellKnownTitle.PC_DISTANCE));
        //////////////// keeping distance stats for mobile //////////////
    }

    /**
     * Does not replace items requested by at least one mobile that is close to
     * the center of the small cell, as defined by parameter
     * space.mu.group.prohibit_rplc_minDist.
     *
     * @param sc
     * @param item
     * @param orderedCached
     * @return
     * @throws Throwable
     */
    @Override
    public Set<Chunk> optForEviction(SmallCell sc, Chunk item, PriorityQueue<Chunk> orderedCached) throws Throwable {

        long minSpaceRequired = item.sizeInBytes();
        double maxThshld = assess(item, sc) / item.sizeInMBs();

        Set<Chunk> evictedItems = new HashSet<>();

        long freeSpace = sc.getCacheAvailable(this);

        double aggrEvictGain = 0.0;
        double aggrEvictSize = 0.0;

        NEXT_CACHED_ITEM:
        while (!orderedCached.isEmpty() && freeSpace < minSpaceRequired) {
            Chunk minItem = orderedCached.poll();

            Set<CachingUser> mus = null; // MUs currently requesting minItem from sc 

            PCDemand.RegistrationInfo dmdRegInfo // info about the currently 
                    // requested cache space by this SC 
                    = sc.dmdRegInfoPC(minItem, this);
            if (dmdRegInfo != null) {/* 
                 * Otherwise if null, then no mobile is currently 
                 * requesting for minItem, i.e. it has remained in the cache
                 * by prior requests which are not active any more.
                 *
                 * Therefore, for the else case, let it be tested for being removed..
                 *
                 * Do not think of multiplying the assessed gain with the 
                 * number of requesting MUs, because the number of MUs is 
                 * already taken into account in the mobility predicition 
                 * probability Q.
                 */
                mus = dmdRegInfo.cachingUsers();
            }

            aggrEvictGain += assess(minItem, sc);
            aggrEvictSize += minItem.sizeInMBs();

            if (aggrEvictGain / aggrEvictSize > maxThshld) {// do not replace if you lose 
                // potentially more gain from the to-be-replaced item.
                return new HashSet<>();// return an empty set 
            }

            evictedItems.add(minItem);
            freeSpace += minItem.sizeInBytes();
        }

        if (freeSpace < minSpaceRequired) {
            return new HashSet<>();// return an empty set. Cannot find enought space
        }
        return evictedItems;
    }

}
