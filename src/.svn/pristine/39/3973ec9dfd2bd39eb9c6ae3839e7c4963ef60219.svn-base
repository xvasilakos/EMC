package sim.space.users.mobile;

import app.properties.valid.Values;
import exceptions.CriticalFailureException;
import exceptions.InconsistencyException;
import exceptions.InvalidOrUnsupportedException;
import exceptions.WrongOrImproperArgumentException;
import java.util.Iterator;
import java.util.Map;
import sim.space.Point;
import sim.space.cell.CellRegistry;
import sim.space.cell.smallcell.SmallCell;
import sim.space.connectivity.ConnectionStatusUpdate;
import util.Couple;

/**
 *
 * @author xvas
 */
public class TraceMU extends MobileUser {

    private double _dx;
    private double _dy;

    public TraceMU(MUBuilder muBuilder, double dx, double dy) throws CriticalFailureException {
        super(muBuilder);
        _dx = dx;
        _dy = dy;
    }

    /**
     * @return the _dx
     */
    public double getDx() {
        return _dx;
    }

    /**
     * @param _dx the _dx to set
     */
    public void setDx(double _dx) {
        this._dx = _dx;
    }

    /**
     * @return the _dy
     */
    public double getDy() {
        return _dy;
    }

    /**
     * @param _dy the _dy to set
     */
    public void setDy(double _dy) {
        this._dy = _dy;
    }

    private Couple<Point, Boolean> selectNewCoordinate(double dx, double dy) {
        boolean loop = howToResetPosition().equals(Values.LOOP_PLUS_NO_RESET);

        Couple<Point, Boolean> newPointisLoopedCoupled;

        Point coordinates = this.coordinates();
        if (dx < 0) {
            // up
            newPointisLoopedCoupled = _area.west(loop, coordinates, Math.abs(dx));/*
                 * use _velocity for distance because it refers to 1 simTime unit
             */
        } else {
            // up
            newPointisLoopedCoupled = _area.east(loop, coordinates, Math.abs(dx));
        }
        boolean isLoopedX = newPointisLoopedCoupled.getSecond();

        coordinates = newPointisLoopedCoupled.getFirst();
        if (dy < 0) {
            // up
            newPointisLoopedCoupled = _area.north(loop, coordinates, Math.abs(dy));/*
                 * use _velocity for distance because it refers to 1 simTime unit
             */
        } else {
            // up
            newPointisLoopedCoupled = _area.south(loop, coordinates, Math.abs(dy));
        }
        boolean isLoopedY = newPointisLoopedCoupled.getSecond();

        newPointisLoopedCoupled.setSecond(isLoopedX || isLoopedY);

        return newPointisLoopedCoupled;
    }

    /**
     * Moves this MU based on the most recently set dx, dy marginal coordinate
     * differences.
     *
     * @return an update on the connectivity status
     * @throws exceptions.InvalidOrUnsupportedException
     * @throws exceptions.WrongOrImproperArgumentException
     *
     */
    @Override
    public ConnectionStatusUpdate move(
            boolean overrideResidencePeriodInSCExpiration,
            boolean overrideStartRoamingTime)
            throws InvalidOrUnsupportedException,
            WrongOrImproperArgumentException {

        if ((!overrideResidencePeriodInSCExpiration && !canMove())
                || (!overrideStartRoamingTime && !afterStartingRoaming())) {
            return _mostRecentConnStatusUpdate;
        }


        /* Point after moving. if looped to the other side of the area, 
         * the boolean field is true.
         */ Couple<Point, Boolean> newPointLoopedCouple = selectNewCoordinate(_dx, _dy);

        return moveToNewPoint(newPointLoopedCouple);
    }

}
