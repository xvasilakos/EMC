package caching.incremental;

import caching.base.AbstractCachingPolicy;
import caching.base.AbstractNaive;
import caching.interfaces.incremental.IIncrementalBase;
import caching.interfaces.rplc.IGainNoRplc;
import sim.Simulation;
import sim.content.Chunk;
import static sim.space.cell.smallcell.BufferBase.BufferAllocationStatus.ItemAlreadyCachedByOtherMUs;
import static sim.space.cell.smallcell.BufferBase.BufferAllocationStatus.Success;
import sim.space.cell.smallcell.SmallCell;
import sim.space.users.CachingUser;

/**
 * @author xvas
 */
public class Naive extends AbstractNaive implements IGainNoRplc, IIncrementalBase {

    private static AbstractCachingPolicy singelton = new Naive();

    public static AbstractCachingPolicy instance() {
        return singelton;
    }

    protected Naive() {
    }

    @Override
    public int cacheDecision(
            Simulation sim, CachingUser mu, Iterable<Chunk> requestChunks, SmallCell hostSC, SmallCell targetSC) throws Throwable {
        int totalSizeCached = 0;
        Iterable<Chunk> items = mu.getRequestsInChunks();
        for (Chunk nxtItem : items) {
            switch (targetSC.cacheItemAttempt(mu, this, nxtItem)) {
                case Success:
                    totalSizeCached += nxtItem.sizeInBytes();
                    break;
                case ItemAlreadyCachedByOtherMUs:
                    break;
            }
        }
        return totalSizeCached;
    }

}
