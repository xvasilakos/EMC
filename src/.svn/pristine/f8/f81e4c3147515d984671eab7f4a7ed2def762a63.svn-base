package sim.space.users;

import app.properties.Networking;
import caching.MaxPop;
import caching.base.AbstractCachingPolicy;
import caching.incremental.Oracle;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import sim.SimulationBase;
import sim.content.Chunk;
import sim.content.request.DocumentRequest;
import sim.space.Point;
import sim.space.cell.MacroCell;
import sim.space.cell.smallcell.SmallCell;

/**
 *
 * @author xvas
 */
public class StationaryUser extends CachingUser {

    public StationaryUser(int id, SimulationBase sim,
            Iterable<AbstractCachingPolicy> cachingPolicies) {

        super(id, sim, cachingPolicies);
    }

    public StationaryUser(int id, SimulationBase sim, int connectedSinceSC,
            SmallCell connectionSC, MacroCell connectionMC,
            Iterable<AbstractCachingPolicy> cachingPolicies) {

        super(id, sim, connectedSinceSC, connectionSC, connectionMC,
                cachingPolicies);
    }

    @Override
    public void consumeData(int timeWindow) throws Throwable {
        for (DocumentRequest nxtReq : getRequests()) {
            nxtReq.cacheForOracle(_currentlyConnectedSC, timeWindow,
                    getSim().getRateSCWlessInChunks()/*in stationary users, 
                        each request get the whole bandwidth to emulate one request per user*/
            );
        }

        super.consumeData(timeWindow);
//xxx
//        String txt
//                = "\nConsumed: "
//                + "\n\t BH: " + getMostRecentlyConsumedBH().get(EMPC_LC_Full.instance()).size()
//                + "\n\t Hits: " + getMostRecentlyConsumedFromCacheHits().get(EMPC_LC_Full.instance()).size()
//                + "\n\t Misses: " + getMostRecentlyCacheMissesPerPolicy().get(EMPC_LC_Full.instance()).size()
//                + "\n\t MC: " + getMostRecentlyConsumedMC().get(EMPC_LC_Full.instance()).size();
//        Utils.trackUser(false,
//                txt,
//                this, true);

        cacheDescisionsPerformRegisterPC(timeWindow,
                getMostRecentlyCacheMissesPerPolicy(),
                getMostRecentlyConsumedBH(),
                getMostRecentlyConsumedMC()
        );

    }

    public void cancelAndDeregisterPCOrders() {
        super.cancelAndDeregisterPCOrders(getCurrentlyConnectedSC());
    }

    /**
     * This is a stationary user. Thus, the default getCoordinates are the
 getCoordinates of the center of the connection cell.
     *
     * @return the getCoordinates of the center of the connection cell
     */
    @Override
    public Point getCoordinates() {
        return getCurrentlyConnectedSC().getCenter();
    }

    private void cacheDescisionsPerformRegisterPC(int timeWindow,
            Map<AbstractCachingPolicy, List<Chunk>> mostRecentlyCacheMissesPerPolicy,
            Map<AbstractCachingPolicy, List<Chunk>> mostRecentlyConsumedBH,
            Map<AbstractCachingPolicy, List<Chunk>> mostRecentlyConsumedMC) throws Throwable {
        setLastSCForCacheDecisions(_currentlyConnectedSC);

//////////////////////// rates are split per each user's request
        float slice = 1.0F; // use 1, not getRequests().size() because one stationary emulates multiple users
        int bhRateInChunks = Math.round(getSim().getRateBHInChunks() * timeWindow / slice);

        for (DocumentRequest nxtReq : getRequests()) {
// update popularity info for requests
            _currentlyConnectedSC.getPopInfo().registerPopInfo(nxtReq);

            for (AbstractCachingPolicy policy : getCachingPolicies()) {
                if (policy instanceof MaxPop
                        || policy instanceof Oracle) {
                    // cached object stay permanently in cache.
                    continue;
                }

                int budgetInChunks = bhRateInChunks;
                List<Chunk> requestToCache = new ArrayList();

// 1. start with  cache missed
                List<Chunk> missed = mostRecentlyCacheMissesPerPolicy.get(policy);
                for (Iterator<Chunk> it = missed.iterator(); it.hasNext() && budgetInChunks-- > 0;) {
                    Chunk nxtChunk = it.next();
                    _currentlyConnectedSC.getDmdPC(policy).registerUpdtInfoPC(nxtChunk, this);
                    requestToCache.add(nxtChunk);
                }

// 2. continue with the ones fetch through the BH (backhaul)
                List<Chunk> bh = mostRecentlyConsumedBH.get(policy);
                for (Iterator<Chunk> it = bh.iterator(); it.hasNext() && budgetInChunks-- > 0;) {
                    Chunk nxtChunk = it.next();
                    _currentlyConnectedSC.getDmdPC(policy).registerUpdtInfoPC(nxtChunk, this);
                    requestToCache.add(nxtChunk);
                }

// 3. finally, the ones downloaded from the MC - it is not likely that budgetInChunks > 0 by now.. 
                List<Chunk> mc = mostRecentlyConsumedMC.get(policy);
                for (Iterator<Chunk> it = mc.iterator(); it.hasNext() && budgetInChunks-- > 0;) {
                    Chunk nxtChunk = it.next();
                    _currentlyConnectedSC.getDmdPC(policy).registerUpdtInfoPC(nxtChunk, this);
                    requestToCache.add(nxtChunk);
                }

// Now cache the ones decided above that fit the budghet of the backhaul 
                _currentlyConnectedSC.cacheDecisions(
                        policy, this, _currentlyConnectedSC, requestToCache
                );

            }

        }
    }
}
