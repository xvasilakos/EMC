package sim.time;

import app.properties.Simulation;
import exceptions.NotIntiliazedException;
import java.awt.Toolkit;
import java.util.logging.Level;
import java.util.logging.Logger;
import sim.ScenariosFactory;
import static sim.time.AbstractClock.realGlobalTimeElapsedStr;
import static sim.time.AbstractClock.realTimeStr;
import static sim.time.SimpleClock.LOGGER;
import util.CommonFunctions;
import static sim.time.AbstractClock.realTimeStr;

/**
 * Clock used for simulations ending after a finite _sim time has passed.
 *
 * @author Xenofon Vasilakos xvas@aueb.gr
 */
public class FiniteTimeClock extends SimpleClock {

    /**
     * Percentage of simulations batch progress with two decimals.
     *
     * @return
     * @throws exceptions.NotIntiliazedException
     */
    public static double globalProgressPercent() throws NotIntiliazedException {
        double completedScenarios = (double) ScenariosFactory.completedScenariosNum() / ScenariosFactory.initialScenariosNum();
//        completedScenarios
//                = completedScenarios == 0
//                        ? (double) ScenariosFactory.consumedScenariosNum() / 2.0 / ScenariosFactory.initialScenariosNum()
//                        : completedScenarios;
        double globalProgressPercent = ((int) (10000 * completedScenarios)) / 100.0;
        return globalProgressPercent;
    }

    public FiniteTimeClock(sim.SimulationBase sim) {
        super(sim);
        if (sim == sim.NONE) {
            maxTime = -1;
            return;
        }

        maxTime = _setup.intProperty(Simulation.Clock.MAX_TIME);

    }

    @Override
    public int tick() throws NormalSimulationEndException {
        return super.tick();
    }

    public int getMaxTime() {
        return maxTime;
    }

    public String globalTimeFinishExpectation() throws NotIntiliazedException {

        double globalProgressPercent = globalProgressPercent();
        if (globalProgressPercent == 0.0) {
            return "[NOT ENOUGH DATA YET]";
        }

        long expectation = (long) (100.0 * realGlobalTimeElapsedL()
                / globalProgressPercent - realGlobalTimeElapsedL());
        return realTimeStr(expectation);
    }

    @Override
    protected void checkEnded(int time) throws NormalSimulationEndException {
        reportProgressLcl(time);
        super.checkEnded(time);

        if (time > maxTime) {
            try {
                Toolkit.getDefaultToolkit().beep();
            } catch (Exception e) {//ignore
            } finally {
                throw new NormalSimulationEndException(
                        "Simulation time expired.");
            }
        }
    }

    /**
     * Percentage of progress with respect to the maximum simulation time
     *
     * @return
     */
    public double progressPercent() {
        return (int) (10000.0 * simTime() / maxTime) / 100.0;
    }

    @Override
    protected void reportProgressLcl(int time) {
        super.reportProgressLcl(time);

        if (isPeriodicLoging(time)) {
            try {

                String msg = LOG_SEPARATOR
                        + "Simulation {0} time {1}:\n"
                        + "\t- Local run time progress {2}%\n"
                        + "\t- Local time elapsed " + realTimeElapsedStr() + "\n"
                        + "\t- Simulation expected to finish in {3}\n"
                        /////////////
                        + (_sim.usesTraceOfRequests()
                                ? LOG_SEPARATOR + "\t- Loaded records from trace: {4} ({5}%)\n"
                                : "")
                        /////////////
                        + LOG_SEPARATOR
                        + "Parallel Running simulations {6}\n"
                        + "\t- Global progress {7}%\n"
                        + "\t\t- Global simulations time elapsed {8}\n\n"
                        + "\t\t- Simulations batch expected to finish in {9}\n\n";

                LOGGER.log(Level.INFO,
                        msg,
                        new Object[]{
                            /*0*//*0*//*0*//*0*//*0*//*0*//*0*//*0*/simID(),
                            /*1*/ simTime(),
                            /*2*/ progressPercent(),
                            /*3*/ realTimeStr(
                                    (100.0 * realTimeElapsedL()
                                    / progressPercent() - realTimeElapsedL())),
                            /*4*/ _sim.getWrkloadConsumed(),
                            /*5*/ _sim.getWrkloadConsumedPercent(),
                            /*6*/ sim.SimulationBase.getRunningSimulations(),
                            /*7*/ globalProgressPercent(),
                            /*8*/ realGlobalTimeElapsedStr(),
                            /*9*/ globalTimeFinishExpectation()
                        });

            } catch (NotIntiliazedException ex) {
                LOGGER.log(Level.SEVERE, null, ex);
            }
        }
    }

    public static Logger LOGGER = Logger.getLogger(FiniteTimeClock.class.getCanonicalName());
    protected final int maxTime;
}
