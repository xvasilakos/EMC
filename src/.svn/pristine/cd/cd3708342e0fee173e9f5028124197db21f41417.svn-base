package caching;

import caching.base.AbstractEPC;
import caching.base.AbstractCachingPolicy;
import caching.base.AbstractPop;
import caching.base.AbstractPricing;
import caching.base.IPop;
import caching.interfaces.rplc.ILRURplc;
import exceptions.CriticalFailureException;
import exceptions.InvalidOrUnsupportedException;
import exceptions.WrongOrImproperArgumentException;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
import sim.content.Chunk;
import sim.space.cell.demand_registry.PCDemand;
import static sim.space.cell.smallcell.BufferBase.BufferAllocationStatus.FailItemOverUtilizes;
import static sim.space.cell.smallcell.BufferBase.BufferAllocationStatus.ItemAlreadyCachedByOtherMUs;
import static sim.space.cell.smallcell.BufferBase.BufferAllocationStatus.ItemAlreadyCachedBySameMU;
import static sim.space.cell.smallcell.BufferBase.BufferAllocationStatus.Success;
import sim.space.cell.smallcell.ITimeBuffer;
import sim.space.cell.smallcell.PricedTimeBuffer;
import sim.space.cell.smallcell.SmallCell;
import sim.space.cell.smallcell.TimeBufferImpl;
import sim.space.users.CachingUser;
import sim.space.users.StationaryUser;
import sim.space.users.mobile.MobileUser;
import util.Couple;

/**
 * A utility class with methods for:
 *
 * Canceling caching requests
 *
 *
 * @author Xenofon Vasilakos xvas@aueb.gr
 */
public abstract class Utils {

    public static final double SMOOTH_FACTOR_FOR_LEGACY_VALUE = 0.95;

    /**
     * Tries to cancel each cached item requested by the mobile, unless it is
     * also cached on behalf of other mobiles.
     *
     * @param cu
     * @param policy
     * @param targetSC
     * @return the canceled requests
     */
    public static Set<Chunk> cancelCachingOrders(CachingUser cu,
            AbstractCachingPolicy policy, SmallCell targetSC) {

        Set<Chunk> itemsRmvd = new HashSet<>();

        for (Chunk nxtReqChunk : cu.getRequestsInChunks()) {
            if (targetSC.bufferContains(policy, cu, nxtReqChunk)) {
                Set<CachingUser> stillRequesting = targetSC.bufferTryEvict(cu, policy, nxtReqChunk);
                /**
                 * There may be still requesting mus, but they may be requesting
                 * with zero probability, because the item was previously
                 * cached!
                 */
                if (stillRequesting.isEmpty()) {
                    itemsRmvd.add(nxtReqChunk);
//                    Utils.trackSC(true,
//                            "chunk " + nxtReqChunk.toSynopsisString() + " "
//                            + "is evicted in cell " + targetSC.getID()
//                            + " by mobile " + cu.getID(),
//                            cu, true);
                }

            }
        }
        return itemsRmvd;
    }

    public static Set<Chunk> optForEvictionLRUAccess(ITimeBuffer lruBuffer, Chunk item) {

        long minSpaceRequired = item.sizeInBytes();
        long freeSpace = lruBuffer.availableSpaceInBytes();

        Set<Chunk> optToEvict = new HashSet<>();

        Couple<Integer, Set<Chunk>> leastRecentlyAccessed = lruBuffer.getLeastRecentlyAccessed();
        if (leastRecentlyAccessed == null) {
            return new HashSet<>();
        }
        Set<Chunk> lRUAccessedSet = new HashSet(leastRecentlyAccessed.getSecond());
        do {
            Iterator<Chunk> lruIter = lRUAccessedSet.iterator();

            while (lruIter.hasNext() && freeSpace < minSpaceRequired) {
                Chunk nxtItem = lruIter.next();
                optToEvict.add(nxtItem);
                freeSpace += nxtItem.sizeInBytes();
            }

            leastRecentlyAccessed = lruBuffer.getLeastRecentlyAccessed();
            lRUAccessedSet = new HashSet(leastRecentlyAccessed.getSecond());
        } while (!lRUAccessedSet.isEmpty() && freeSpace < minSpaceRequired);

        if (freeSpace < minSpaceRequired) {
            return new HashSet<>();// return an empty set. Cannot find enought space
        }

        return optToEvict;
    }

    /**
     * Applies to cases of naive and Oracle caching.
     *
     * @param lruMethod
     * @param mu
     * @param sc
     * @param poll
     * @return
     * @throws Throwable
     */
    public static Set<Chunk> naiveLRUCacheDecision(
            ILRURplc lruMethod, CachingUser mu, SmallCell sc, boolean poll)
            throws Throwable {
        Iterable<Chunk> chuunks = mu.getRequestsInChunks();
        Set<Chunk> reqIDsRplced = new HashSet<>();
        AbstractCachingPolicy cachingMethod = CachingPoliciesFactory.getCachingPolicy(lruMethod.toString());
        TimeBufferImpl buff = (TimeBufferImpl) sc.getBuffer(cachingMethod);

        for (Chunk nxtItem : chuunks) {
            switch (sc.cacheItemAttempt(mu, cachingMethod, nxtItem)) {
                case Success:
                    break;
                case ItemAlreadyCachedBySameMU:/*
                * Do nothing.. cachingMethod can happen in case the item requested from 
                * the same mu in the past has not been replaced so far.
                     */

                    break;
                case ItemAlreadyCachedByOtherMUs:
                    break;
                case FailItemOverUtilizes:
                    Set<Chunk> optForEviction = lruMethod.optForEviction(buff, nxtItem);
                    if (optForEviction.isEmpty()) {
                        continue;
                    }

                    for (Chunk item2evict : optForEviction) {
                        Set<CachingUser> theCachers = sc.bufferCachers(cachingMethod, item2evict);
                        for (CachingUser nxtCacher : theCachers) {
                            sc.removeCacher(nxtCacher, cachingMethod, item2evict);
                        }
                        sc.bufferForceEvict(cachingMethod, item2evict);
                        reqIDsRplced.add(item2evict);
                    }

// do not do the following because it is normal if items are bigger than buffer sizes:
//                    if (sc.cacheItemAttempt(mu, cachingMethod, nxtItem) != Success) {
//                        throw new InconsistencyException("Failed to cache item " + nxtItem
//                                + " even thought cache replacement took place for: "
//                                + util.CommonFunctions.toString(optForEviction)
//                        );
//                    }
                    break;
            }
        }
        return reqIDsRplced;
    }

    public static final boolean isSpaceAvail(AbstractCachingPolicy cachePolicy, SmallCell sc, long size) {
        return sc.buffAvailable(cachePolicy) >= size;
    }

    public static Set<Chunk> pricedLRUCacheDecision(ILRURplc lruMethod, CachingUser mu, SmallCell sc) throws Throwable {
        Iterable<Chunk> chunks = mu.getRequestsInChunks();
        Set<Chunk> itemsRplcd = new HashSet<>();
        AbstractPricing cachingMethod = (AbstractPricing) CachingPoliciesFactory.getCachingPolicy(lruMethod.toString());
        PricedTimeBuffer buff = (PricedTimeBuffer) sc.getBuffer(cachingMethod);

        for (Chunk nxtItm : chunks) {

            Chunk nxtIDToItem = nxtItm;

            Chunk nxtItem = nxtItm;

            double cachePrice = sc.cachePricePoll(false, nxtItem, cachingMethod);

            double assessed = 1.0 / nxtItem.sizeInMBs();
            if (cachingMethod instanceof AbstractEPC) {
                assessed *= ((AbstractEPC) cachingMethod).assess(mu, nxtItem, sc);
            } else if (cachingMethod instanceof AbstractPop) {
                assessed *= ((AbstractPop) cachingMethod).assess(nxtItem, sc);
            } else {
                throw new InvalidOrUnsupportedException("Unsupported caching policy type: " + cachingMethod.toString());
            }

            if (assessed >= cachePrice) {
                if (sc.isCached(cachingMethod, nxtItm)) {
                    sc.addCacher(mu, cachingMethod, nxtItm);
                    continue;
                }// otherwise, it may need to evict:

                //<editor-fold defaultstate="collapsed" desc="if cache replacement needed">
                if (isSpaceAvail(cachingMethod, sc, nxtIDToItem.sizeInBytes())) {// needs cache replacement
                    Set<Chunk> optForEviction = lruMethod.optForEviction(buff, nxtIDToItem);
                    if (optForEviction.isEmpty()) {
                        break;
                    }

                    for (Chunk item2evict : optForEviction) {
                        Set<CachingUser> bufferCachers = sc.bufferCachers(cachingMethod, item2evict);
                        for (CachingUser muCacher : bufferCachers) {
                            sc.removeCacher(muCacher, cachingMethod, item2evict);
                        }
                        if (sc.bufferForceEvict(cachingMethod, item2evict).isEmpty()) {
                            itemsRplcd.add(item2evict);
                        }
                    }
                }
                //</editor-fold>

                sc.cacheItemAttempt(mu, cachingMethod, nxtItm);
            } else if (sc.getSim().getRandomGenerator().randProbability() > 0.9) {/*
             * instead of using a cache price based only on items that have 
             * gain > price =>
                 */

                HashSet<Chunk> lrus = new HashSet(buff.LRUAccessed());// copy to avoid concurrent modificatoin exceptions
                if (lrus.isEmpty()) {
                    continue;
                }
                Chunk item2evict = lrus.iterator().next();

                Set<CachingUser> bufferCachers = sc.bufferCachers(cachingMethod, item2evict);
                if (bufferCachers != null) {
                    for (CachingUser muCacher : bufferCachers) {
                        sc.removeCacher(muCacher, cachingMethod, item2evict);
                    }
                }
                sc.bufferForceEvict(cachingMethod, item2evict);
                itemsRplcd.add(item2evict);
            }
        }
        return itemsRplcd;
    }

//    public static double assessAvgEMPC(Chunk item, SmallCell sc, AbstractPop cachePolicy) throws Throwable {
//        PCDemand.RegistrationInfo nfo = sc.dmdRegInfoPC(item);
//        double avgProb = nfo != null ? nfo.sumTransProbs() / nfo.cachingUsers().size() : 0.0;
//
//        double q = avgProb;
//        double f = sc.dmdPopularity(item.referredContentDocument(), cachePolicy);
//        double w = Utils.computeAvgW(sc);
//        //<editor-fold defaultstate="collapsed" desc="tmp commented">
////      sc.getSim().getStatsHandle().updtSCCmpt5(
////            f,
////            new UnonymousCompute5(
////                  cachePolicy, UnonymousCompute5.WellKnownTitle.F_POP
////            )
////      );
////      sc.getSim().getStatsHandle().updtSCCmpt5(
////            q,
////            new UnonymousCompute5(
////                  cachePolicy, UnonymousCompute5.WellKnownTitle.Q_POP
////            )
////      );
////</editor-fold>
//        return (q + w * f) * gainOfTransferSC(item, sc);
//    }
//
//   
//    public static double assessAvgEMC(Chunk item, SmallCell sc, AbstractEPC cachePolicy) throws Throwable {
//        PCDemand.RegistrationInfo nfo = sc.getDmdPC().getRegisteredInfo(item);
//        double prob = nfo != null ? nfo.sumTransProbs() / nfo.cachingUsers().size() : 0;
//        return prob * gainOfTransferSC(item, sc);
//    }
    public static double assessEMC(Chunk item, SmallCell sc, AbstractEPC cachePolicy) {
        PCDemand.RegistrationInfo nfo = sc.dmdRegInfoPC(item, cachePolicy);
        double Q = nfo != null ? nfo.sumTransProbs() : 0.0;

        double assessment = Q * item.gainOfTransferSCCacheHit();
        return assessment;
    }

    public static double assessEMPC(Chunk theChunk, SmallCell sc, IPop cachePolicy) {

        PCDemand.RegistrationInfo nfo = sc.dmdRegInfoPC(theChunk, (AbstractCachingPolicy) cachePolicy);
        double Q = nfo != null ? nfo.sumTransProbs() : 0.0;
        double f = sc.dmdPopularity(theChunk.referredContentDocument(), cachePolicy);
        double w = sc.getDmdLclForW().computeAvgW();

        if (w == -1) {
            w = 0;
            //hack.. 
        }

        double assessment = (Q + w * f) * theChunk.gainOfTransferSCCacheHit();
        //<editor-fold defaultstate="collapsed" desc="tmp commented">
//@todo commented to save computation      sc.getSim().getStatsHandle().updtSCCmpt5(
//            f,
//            new UnonymousCompute5(
//                  this, UnonymousCompute5.WellKnownTitle.F_POP
//            )
//      );
//      sc.getSim().getStatsHandle().updtSCCmpt5(
//            q,
//            new UnonymousCompute5(
//                  this, UnonymousCompute5.WellKnownTitle.Q_POP
//            )
//      );
//</editor-fold>
        return assessment;
    }

    public static double assessEPC_with_Pop(CachingUser cu, Chunk item, SmallCell sc,
            IPop cachePolicy) {

        double q = 0.0;
        if (cu == null) {
            q = 0.0;
        } else {

            if (cu instanceof MobileUser) {
                q = sc.simCellRegistry().handoffProbability((MobileUser) cu, cu.getCurrentlyConnectedSC(), sc);
            }
            if (cu instanceof StationaryUser) {
                q = 1.0;
            }

            throw new UnsupportedOperationException();

        }

        double f = sc.dmdPopularity(item.referredContentDocument(), cachePolicy);
        double w = sc.getDmdLclForW().computeAvgW();

        return (q + w * f) * item.gainOfTransferSCCacheHit();
    }

    public static double assessOnlyPop(AbstractPop cachePolicy, Chunk item,
            SmallCell sc) {
        double f = sc.dmdPopularity(item.referredContentDocument(), cachePolicy);
        return f * item.gainOfTransferSCCacheHit();
    }

    public static double assessEPC(CachingUser cu, Chunk item, SmallCell sc) {
        double prob = 1.0;

        if (cu instanceof MobileUser) {
            prob = sc.simCellRegistry().handoffProbability((MobileUser) cu, cu.getCurrentlyConnectedSC(), sc);
            return prob * item.gainOfTransferSCCacheHit();
        }
        if (cu instanceof StationaryUser) {
            return item.gainOfTransferSCCacheHit();
        }

        throw new CriticalFailureException(new WrongOrImproperArgumentException());
    }

    public static String toMB(double bytes) {
        return "" + (bytes / 1024.0 / 1024.0);
    }

    public static String toMB(long bytes) {
        return "" + (bytes / 1024.0 / 1024.0);
    }

}
