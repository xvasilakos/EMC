package sim.space.users;

import caching.MaxPop;
import caching.base.AbstractCachingPolicy;
import caching.incremental.Oracle;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import sim.run.SimulationBaseRunner;
import sim.content.Chunk;
import sim.content.request.DocumentRequest;
import sim.space.Point;
import sim.space.cell.MacroCell;
import sim.space.cell.smallcell.SmallCell;
import utilities.Couple;

/**
 *
 * @author xvas
 */
public class StationaryUser extends CachingUser {

    public StationaryUser(int id, SimulationBaseRunner sim,
            Collection<AbstractCachingPolicy> cachingPolicies) {

        super(id, sim, cachingPolicies);
    }

    public StationaryUser(int id, SimulationBaseRunner sim, int connectedSinceSC,
            SmallCell connectionSC, MacroCell connectionMC,
            Collection<AbstractCachingPolicy> cachingPolicies) {

        super(id, sim, connectedSinceSC, connectionSC, connectionMC,
                cachingPolicies);
    }

    public void cancelAndDeregisterPCOrders() {
        super.cancelAndDeregisterPCOrders(getCurrentlyConnectedSC());
    }

    /**
     * This is a stationary user. Thus, the default getCoordinates are the
     * getCoordinates of the center of the connection cell.
     *
     * @return the getCoordinates of the center of the connection cell
     */
    @Override
    public Point getCoordinates() {
        return getCurrentlyConnectedSC().getCenter();
    }

    @Override
    public void addAllRequests(Collection<DocumentRequest> requests) throws Throwable {
        for (DocumentRequest r : requests) {
            addRequest(r);
        }
    }

    @Override
    public void addRequest(DocumentRequest r) throws Throwable {
        super.addRequest(r);

        double handoverAvgTime = _currentlyConnectedSC.getSmoothedHandoverDuration();

        _currentlyConnectedSC.getPopInfo().registerPopInfo(r);
        cache(handoverAvgTime, r);

        r.cacheForOracle(_currentlyConnectedSC,
                new Couple(handoverAvgTime, 0.05 * handoverAvgTime),
                getSim().getRateSCWlessInChunks()/*in stationary users, 
                        each request get the whole bandwidth to emulate one request per user*/
        );
    }

    private void cache(double timeWindow, DocumentRequest r) throws Throwable {

//////////////////////// rates are split per each user's request
        float slice = 1.0F; // use 1, not getRequests().size() because one stationary emulates multiple users

//commented out the following
        long bhRateInChunks = Math.round(getSim().getRateBHInChunks() * timeWindow / slice);
        for (AbstractCachingPolicy policy : getCachingPolicies()) {
            if (policy instanceof MaxPop
                    || policy instanceof Oracle) {
                // cached object stay permanently in cache.
                continue;
            }

            long budgetInChunks = bhRateInChunks;// this is how much you can fetch from the backhaul and request to cache
            List<Chunk> requestToCache = new ArrayList();

            List<Chunk> unconsumedLst = r.getUnconsumedChunksInSequence(policy);
            for (Iterator<Chunk> it = unconsumedLst.iterator(); it.hasNext() && budgetInChunks-- > 0;) {
                Chunk nxtChunk = it.next();
                _currentlyConnectedSC.getDmdPC(policy).registerUpdtInfoPC(nxtChunk, this, 0);
                requestToCache.add(nxtChunk);
            }

            _currentlyConnectedSC.cacheDecisions(
                    policy, this, _currentlyConnectedSC, requestToCache
            );

        }
    }

    public void forceCompleteRequests() {
        for (DocumentRequest r : getRequests()) {
            r.forceComplete(simTime());
        }
    }
}
