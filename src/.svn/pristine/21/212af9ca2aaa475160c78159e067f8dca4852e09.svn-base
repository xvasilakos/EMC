package sim.space.cell.smallcell;

import app.properties.Cost;
import app.properties.valid.Values;
import caching.base.AbstractCachingPolicy;
import caching.interfaces.rplc.IGainRplc;
import exceptions.InconsistencyException;
import java.util.NoSuchElementException;
import java.util.Set;
import sim.Scenario;
import sim.run.SimulationBaseRunner;
import sim.content.Chunk;
import sim.space.users.CachingUser;

/**
 * Type of buffer _used for caching decisions using prices.
 *
 * @author Xenofon Vasilakos xvas@aueb.gr
 */
public class PricedBuffer extends BufferBase {

    /**
     * The price of this buffer, as defined by the dynamic or fixed pricing
     * scheme in use.
     */
    protected double _price;
    private double _price4Rplc;

    /**
     * The pricing scheme in use.
     */
    private final String _pricingScheme;
    /**
     * The factor _used for updating the dynamic price of this buffer.
     */
    private final double _gamma;
    /**
     * The target utilization, which is _used for some dynamic pricing schemes
     * only.
     */
    private final double _costEPCTrgtUtilization;

    public PricedBuffer(SimulationBaseRunner sim, SmallCell cell, long capacity) {
        super(sim, cell, capacity);

        Scenario setup = _simulation.getScenario();

        _pricingScheme = setup.stringProperty(Cost.Cache.PRICING_SCHEME);
        _gamma = setup.doubleProperty(Cost.EPC.GAMMA);

        _costEPCTrgtUtilization = setup.doubleProperty(Cost.EPC.TARGET_UTILIZATION);

        _used = 0;
        _price = 0.0;
        _price4Rplc = 0.0;
    }

    /**
     * @param item
     * @param cachingPolicy
     * @return the list of mobiles still requesting the cached item.
     */
    @Override
    public Set<CachingUser> deallocate(Chunk item, CachingUser mu, AbstractCachingPolicy cachingPolicy, SmallCell sc)
            throws NoSuchElementException {

//        Utils.appendLogNewRecord("Pre deallocation price " + sc.cachePrice((AbstractPricing) cachingPolicy), sc, cachingPolicy);
//        Utils.appendLog("Chunk " + item, sc, cachingPolicy);
        double pricePoll = PricedBuffer.this.pricePoll(true, item);
        double usedPrev = getUsed();
//
//        Utils.appendLog("Used space before " + getUsed(), sc, cachingPolicy);
//        Utils.appendLog("Util before " + utilization(), sc, cachingPolicy);

        Set<CachingUser> mobsStillRequesting = super.deallocate(item, mu, cachingPolicy, sc);
        if (!mobsStillRequesting.isEmpty()) {// if the super class implementation did evict the item
            _price = pricePoll;
        }

//        Utils.appendLog("mobsStillRequesting " + mobsStillRequesting.size(), sc, cachingPolicy);
//        Utils.appendLog("Used space after " + getUsed(), sc, cachingPolicy);
//        Utils.appendLog("Util after " + utilization(), sc, cachingPolicy);
//
//        Utils.appendLog("Post deallocation price " + sc.cachePrice((AbstractPricing) cachingPolicy), sc, cachingPolicy);
        return mobsStillRequesting;
    }

    public Set<CachingUser> deallocate(Chunk item, CachingUser mu, IGainRplc cachingMthd, SmallCell sc) throws NoSuchElementException, Throwable {
        Set<CachingUser> result = super.deallocate(item, mu, (AbstractCachingPolicy) cachingMthd, sc);
        //CAUTION, must reduce _used before re-assessing price
        priceUpdt4Rplc(cachingMthd);
        return result;
    }

    /**
     * Computes price by considering buffer utilization computed only over the
     * cached items for which the expected (assessed) gain is lower than the
     * current price. This method of price computation is suitable for cache
     * replacement decisions based on gain, which are used for AbstractEPCPop
     * descendants which use popularity and summary of transition probabilities
     * for all requestors .
     *
     * @param mthd
     * @return
     * @throws Throwable
     */
    public double priceUpdt4Rplc(IGainRplc mthd) throws Throwable {
//        appendLog("Updating price.. ", _cell, (AbstractCachingPolicy) mthd);
//        appendLog("Price before update= " + getPrice4Rplc(), _cell, (AbstractCachingPolicy) mthd);

        double consideredUtil = utilization4Rplc(mthd);

        setPrice4Rplc(
                getPrice4Rplc() + getGamma() * (consideredUtil - getTrgtUtililzation())
        );
        if (getPrice4Rplc() < 0) {
            setPrice4Rplc(0);
        }

//        appendLog("Price after update= " + getPrice4Rplc(), _cell, (AbstractCachingPolicy) mthd);
        return getPrice4Rplc();
    }

    public double utilization4Rplc(IGainRplc mthd) throws Throwable {
        double used4Price = 0.0;
        double price4Rplc = getPrice4Rplc();

//        if (price4Rplc > 0) {
//            Utils.appendLog("#util computation for non-zero price: " + price4Rplc,
//                    _cell, (AbstractCachingPolicy) mthd);
//            Set<Item> cachedChunksUnmodifiable = getCachedItems();
//            for (Chunk nxtItem : cachedChunksUnmodifiable) {
//                double assessment = mthd.assess(nxtItem, _cell) / nxtItem.sizeInMBs();
//
//                Utils.appendLog("#gain/size " + assessment,
//                        _cell, (AbstractCachingPolicy) mthd);
//
//                if (assessment >= price4Rplc) {
//                    used4Price += nxtItem.sizeInBytes();
//
//                    Utils.appendLog("#item included in utilization computation",
//                            _cell, (AbstractCachingPolicy) mthd);
//                }
//
//                Utils.appendLog("#updated util = " + (used4Price / _capacity),
//                        _cell, (AbstractCachingPolicy) mthd);
//            }
//        } else {
        Set<Chunk> cachedItems = getCachedItems();
        for (Chunk nxtItem : cachedItems) {
            if (mthd.assess(nxtItem, _cell) / nxtItem.sizeInMBs() >= price4Rplc) {
                used4Price += nxtItem.sizeInBytes();
            }
        }
//        }

        return used4Price / _capacity;
    }

    /**
     * Computes and returns the buffer price after polling to cache the item in
     * the buffer (respectively to evict the item depending on the actionFlag
     * parameter value).
     *
     * Note that the price does not reflect whether there is available space for
     * caching the item or not.
     *
     *
     * @param deallocate true if this call is for evicting the items, false if
     * it is for adding the items.
     * @param item the item polled to be cached or evicted from items.
     * @return The polled price
     */
    double pricePoll(boolean deallocate, Chunk item) {
        if (item == null) {
            throw new InconsistencyException(
                    "No item passed: " + item);
        }
        switch (_pricingScheme) {
            case Values.DYNAMIC__TYPE_01:
                return pricingDynamic01(item, deallocate);

            case Values.DYNAMIC__TYPE_02:
                return pricingDynamic02(item, deallocate);
        }
        // if reached here, then ..
        throw new UnsupportedOperationException(
                "Unknown or unsupported parameter value: " + _pricingScheme);
    }

    double pricePoll() throws Throwable {

        switch (_pricingScheme) {
            case Values.DYNAMIC__TYPE_01:
                return pricingDynamic01(null, false);

            case Values.DYNAMIC__TYPE_02:
                return pricingDynamic02(null, false);
        }
        // if reached here, then ..
        throw new UnsupportedOperationException(
                "Unknown or unsupported parameter value: " + _pricingScheme);
    }

    /**
     * See properties description for parameter cost.cache.pricing_scheme when
     * value dynamic.type_01 is _used.
     *
     * @param item the list of items polled to add/evict
     * @param deallocate true for eviction, otherwise false for addition.
     * @return
     */
    private double pricingDynamic01(Chunk item, boolean deallocate) {
        double pricePolled;
        long size = item == null ? 0 : item.sizeInBytes();
        double polledUtil = utilizationPollAndCheck(size, deallocate);

        pricePolled = getPrice() + getGamma() * (polledUtil - getTrgtUtililzation());
        pricePolled = pricePolled < 0 ? 0 : pricePolled; // do not allow negative values
        return pricePolled;
    }

    /**
     * See properties description for parameter cost.cache.pricing_scheme when
     * value dynamic.type_02 is _used.
     *
     * @param item the list of items polled to add/evict
     * @param deallocate true for eviction, otherwise false for addition.
     * @param cachableItems the items than fit to be cached.
     * @return
     */
    private double pricingDynamic02(Chunk item, boolean deallocate) {
        double pricePolled;
        long size = item == null ? 0 : item.sizeInBytes();
        double polledUtil = utilizationPollAndCheck(size, deallocate);

        if (polledUtil > getTrgtUtililzation()) {
            pricePolled = getPrice() + getGamma() * (polledUtil - getTrgtUtililzation());
        } else {
            pricePolled = 0.0;
        }

        return pricePolled;
    }

    @Override
    public String toString() {
        StringBuilder _toString = new StringBuilder(180);
        Set<Chunk> items = _cachingUsersPerChunk.keySet();
        _toString.append("Buffer_").append(_cell.getID()).append(" buffers: ");
        for (Chunk item : items) {

            _toString.append("<item=").append(item).append(" cached by: ")
                    .append(utils.CommonFunctions.toString(_cachingUsersPerChunk.values()))
                    .append(">; ");
        }
        return _toString.toString();

    }

    /**
     * The factor _used for updating the dynamic price of this buffer.
     *
     * @return the _gamma
     */
    public double getGamma() {
        return _gamma;
    }

    /**
     * The target utilization, which is _used for some dynamic pricing schemes
     * only.
     *
     * @return the target utilization
     */
    public double getTrgtUtililzation() {
        return _costEPCTrgtUtilization;
    }

    /**
     * The price of this buffer, as defined by the dynamic or fixed pricing
     * scheme in use.
     *
     * @return the price
     */
    public double getPrice() {
        return _price;
    }

    public double setPrice(double price) {
        return _price = price;
    }

    /**
     * @return the _price4Rplc
     */
    public double getPrice4Rplc() {
        return _price4Rplc;
    }

    /**
     * @param _price4Rplc the _price4Rplc to set
     */
    void setPrice4Rplc(double _price4Rplc) {
        this._price4Rplc = _price4Rplc;
    }

    @Override
    public long availableSpaceInBytes() {
        return (long) (_capacity - getUsed());
    }

}
